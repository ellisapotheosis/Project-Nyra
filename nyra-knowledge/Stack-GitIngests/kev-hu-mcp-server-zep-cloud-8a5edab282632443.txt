Directory structure:
└── kev-hu-mcp-server-zep-cloud/
    ├── README.md
    ├── claude_desktop_config.json.example
    ├── SECURITY.md
    ├── SETUP_GUIDE.md
    ├── .env.example
    ├── config/
    │   ├── claude_desktop_config.json.example
    │   ├── requirements.txt
    │   └── .env.example
    ├── core/
    │   ├── run_server.py
    │   ├── zep_cloud_client.py
    │   └── zep_cloud_server.py
    ├── scripts/
    │   ├── README.md
    │   ├── check_security.bat
    │   ├── check_security.sh
    │   ├── check_user_exists.py
    │   ├── create_specific_user.py
    │   ├── mcp_wrapper.bat
    │   ├── mcp_wrapper.sh
    │   ├── run_server.bat
    │   ├── run_server.sh
    │   ├── test_claude_error.py
    │   ├── test_claude_json.py
    │   ├── test_dict_json.py
    │   ├── test_graph_data.py
    │   ├── test_graph_search.py
    │   ├── test_json_data.py
    │   ├── test_json_handling.py
    │   ├── test_mcp_add_graph_data.py
    │   └── test_server_start.py
    └── tests/
        ├── test_comprehensive.py
        ├── test_specific_user.py
        └── test_zep_cloud_client.py

================================================
FILE: README.md
================================================
# MCP Server for Zep Cloud

MCP Server for Zep Cloud provides a bridge between Claude Desktop and the Zep Cloud API, enabling memory management for AI assistants.

## Repository Structure

The repository has been organized into the following directories:

- **core/**: Core functionality files
  - `zep_cloud_client.py`: Client implementation for the Zep Cloud API
  - `zep_cloud_server.py`: MCP server providing tools for Claude Desktop
  - `run_server.py`: Standalone script to run the server directly

- **scripts/**: Utility scripts for operations
  - `check_user_exists.py`: Utility to check if a user exists in Zep Cloud
  - `create_specific_user.py`: Script to create a specific user in Zep Cloud
  - `run_server.sh` / `run_server.bat`: Shell scripts to run the server with proper environment setup
  - Various other utility scripts for testing and debugging

- **tests/**: Test scripts organized by functionality
  - `test_specific_user.py`: Comprehensive test for all user operations
  - `test_zep_cloud_client.py`: Unit tests for the Zep Cloud client
  - `test_comprehensive.py`: Complete API tests for all features

- **config/**: Configuration files
  - `.env.example`: Template for environment configuration
  - `.env.new`: Updated environment configuration
  - `claude_desktop_config.json.example`: Template for Claude Desktop configuration
  - `requirements.txt`: Package dependencies

## Features

- **User Management**: Create, retrieve, update, and delete users in Zep Cloud
- **Collections Management**: Create and manage memory collections
- **Memory Operations**: Add, retrieve, and search memories
- **Modern Implementation**: Uses the FastMCP approach for a more efficient and maintainable server
- **Fallback Mode**: Automatically runs in fallback mode if Zep Cloud API is not accessible

## Requirements

- Python 3.8+
- Zep Cloud API key

## Installation

1. Clone this repository:
```bash
git clone https://github.com/yourusername/mcp-server-zep-cloud.git
cd mcp-server-zep-cloud
```

2. Create and activate a virtual environment:
```bash
# On macOS/Linux
python -m venv venv
source venv/bin/activate

# On Windows
python -m venv venv
venv\Scripts\activate
```

3. Install the required packages:
```bash
pip install -r config/requirements.txt
```

4. Copy the `config/.env.example` file to `.env` and add your Zep Cloud API key:
```bash
cp config/.env.example .env
```

Edit the `.env` file and add your Zep Cloud API key:
```
ZEP_API_KEY=your_api_key_here
```

## Usage

### Starting the Server

To start the server on macOS/Linux:
```bash
cd scripts
./run_server.sh
```

Or on Windows:
```bash
cd scripts
run_server.bat
```

The server will start on `http://127.0.0.1:8000` by default.

### Testing API Connectivity

To test if a user exists in Zep Cloud:
```bash
cd scripts
python check_user_exists.py [user_id]
```

To create a specific user in Zep Cloud:
```bash
cd scripts
python create_specific_user.py
```

### Fallback Mode

If the server cannot connect to the Zep Cloud API (due to authentication issues, network problems, or other reasons), it will automatically start in fallback mode. In this mode:

- All API operations will be simulated and will return success
- No actual data will be sent to or received from the Zep Cloud API
- Warning messages will be logged to indicate that the server is running in fallback mode
- The server will remain operational, allowing the Claude Desktop integration to function

To learn more about potential authentication issues and how to fix them, see the [AUTHENTICATION_NOTE.md](AUTHENTICATION_NOTE.md) file.

## Configuring Claude Desktop

1. Open your Claude Desktop configuration file at:
   - macOS: `~/Library/Application Support/Claude/claude_desktop_config.json`
   - Windows: `%APPDATA%\Claude\claude_desktop_config.json`

2. Update the configuration with the absolute paths to your Python executable and server script:
```json
{
  "mcpServers": {
    "zep-cloud": {
      "command": "/ABSOLUTE/PATH/TO/venv/bin/python",
      "args": [
        "/ABSOLUTE/PATH/TO/core/zep_cloud_server.py"
      ]
    }
  }
}
```

**Important Notes**:
- Replace `/ABSOLUTE/PATH/TO/` with the actual path to your Python executable in the virtual environment and the server script.
- Use absolute paths, not relative paths.
- On Windows, use double backslashes in paths (e.g., `C:\\Users\\YourUsername\\...`).

## Available Tools in Claude Desktop

Once configured, Claude Desktop will have access to the following tools:

1. **User Management**:
   - `create_user`: Create a new user
   - `get_user`: Get details of a user
   - `update_user`: Update a user's metadata
   - `delete_user`: Delete a user
   - `list_users`: List all users

2. **Collections Management**:
   - `create_collection`: Create a new collection
   - `get_collection`: Get details of a collection
   - `update_collection`: Update a collection's metadata
   - `delete_collection`: Delete a collection
   - `list_collections`: List all collections

3. **Memory Operations**:
   - `add_memory`: Add a memory to a collection for a user
   - `get_memory`: Get a memory from a collection for a user
   - `list_memories`: List memories from a collection for a user
   - `search_memories`: Search memories from a collection for a user

4. **Connectivity**:
   - `check_connection`: Check connection status with the Zep Cloud API

## Troubleshooting

For troubleshooting information, please see the [AUTHENTICATION_NOTE.md](AUTHENTICATION_NOTE.md) document, which contains detailed information about API connectivity and authentication issues.

## Security Considerations

### API Key Protection
- **NEVER commit your API key to version control**. The `.gitignore` file is configured to prevent `.env` files from being committed.
- Use the provided `.env.example` as a template and create your own `.env` file with your actual API key.
- Regularly rotate your API keys, especially if you suspect they might have been compromised.

### Configuration Files
- Personal configuration files like `claude_desktop_config.json` contain system-specific paths and should not be committed to version control.
- Use the provided `claude_desktop_config.json.example` as a reference to create your own configuration.

### First-Time Setup for Contributing
1. Always ensure `.gitignore` is committed before adding any code or configuration files
2. Copy `.env.example` to `.env` and add your API key
3. Copy `claude_desktop_config.json.example` to `claude_desktop_config.json` and update with your paths
4. Verify that sensitive files are being ignored before committing:
   ```bash
   git status --ignored
   ```

### Security Checks
Before committing code, always check that you haven't accidentally included:
- API keys or credentials
- Personal file paths or usernames
- Log files that might contain sensitive information
- Temporary files with debug information


================================================
FILE: claude_desktop_config.json.example
================================================
{
    "mcpServers": {
        "zep-cloud": {
            "command": "path/to/your/venv/bin/python",
            "args": [
                "path/to/your/mcp-server-zep-cloud/core/zep_cloud_server.py"
            ]
        }
    }
} 


================================================
FILE: SECURITY.md
================================================
# Security Policy

## Protecting Your API Keys and Sensitive Information

This document outlines security best practices for the MCP Server for Zep Cloud project.

### API Key Protection

1. **Never commit API keys to version control**
   - The `.gitignore` file is configured to prevent `.env` files from being committed
   - Always use the `.env.example` as a template to create your own `.env` file locally

2. **Rotate API keys regularly**
   - Periodically rotate your Zep Cloud API keys, especially if you suspect they might have been compromised
   - Update your `.env` file immediately after rotating keys

3. **Limit API key permissions**
   - When possible, use API keys with the minimum necessary permissions for your use case

### Configuration Files

1. **Personal configuration**
   - Files like `claude_desktop_config.json` contain personal paths and should not be committed
   - Use the example templates provided and create your own local versions

2. **Environment variables**
   - Store all sensitive information in environment variables via the `.env` file
   - Never hardcode credentials in your application code

### Development Practices

1. **First-time setup**
   - Always ensure the `.gitignore` file is in place and committed first
   - Follow the setup instructions in the README.md for a secure configuration

2. **Before committing**
   - Review changes with `git diff` to ensure no secrets are being committed
   - Use `git status --ignored` to verify sensitive files are being ignored

3. **If you accidentally commit sensitive information**
   - Immediately rotate any exposed credentials
   - Contact repository administrators for help with cleaning the Git history
   - Consider using tools like BFG Repo-Cleaner or git-filter-repo to remove sensitive data

### Report Security Issues

If you discover any security issues with this project, please contact the maintainers directly.

## Recommended Security Tools

- **Git Hooks**: Consider using pre-commit hooks to prevent committing sensitive information
- **Secret Scanning**: Tools like GitGuardian or GitHub's secret scanning feature can help detect leaked secrets
- **Environment Management**: Tools like direnv can help manage environment variables securely

Remember: Security is everyone's responsibility. When in doubt, err on the side of caution and ask for help. 


================================================
FILE: SETUP_GUIDE.md
================================================
# Setup Guide for Claude Desktop Integration

This guide will help you fix the "spawn python ENOENT" error and properly configure your Claude Desktop to work with the Zep Cloud MCP server.

## Fix for "spawn python ENOENT" Error

The "spawn python ENOENT" error occurs when Claude Desktop cannot find the Python executable. Follow these steps to fix it:

### Step 1: Find the full path to your Python executable

**On macOS/Linux:**
```bash
which python3
```
This will return something like `/usr/local/bin/python3` or `/usr/bin/python3`

**On Windows:**
```cmd
where python
```
This will return something like `C:\Python39\python.exe`

### Step 2: Find the full path to your server script

**On macOS/Linux:**
```bash
pwd
```
When run from the server directory, this will give you the current directory path.

**On Windows:**
```cmd
cd
```
This will show your current directory.

### Step 3: Set up the Claude Desktop configuration

1. Locate or create your Claude Desktop configuration file:
   - macOS: `~/Library/Application Support/Claude/claude_desktop_config.json`
   - Windows: `%AppData%\Claude\claude_desktop_config.json`

2. Edit the file to use the full paths you found:

```json
{
    "mcpServers": {
        "zep-cloud": {
            "command": "/YOUR/PYTHON/PATH/FROM/STEP1",
            "args": [
                "/YOUR/SERVER/PATH/FROM/STEP2/zep_cloud_server.py"
            ]
        }
    }
}
```

3. Replace:
   - `/YOUR/PYTHON/PATH/FROM/STEP1` with the Python path you found in Step 1
   - `/YOUR/SERVER/PATH/FROM/STEP2` with the server directory path you found in Step 2

### Step 4: Restart Claude Desktop

After saving the configuration file, completely restart Claude Desktop.

## Example Configurations

### macOS Example
```json
{
    "mcpServers": {
        "zep-cloud": {
            "command": "/usr/local/bin/python3",
            "args": [
                "/Users/username/projects/mcp-zep-cloud-server/zep_cloud_server.py"
            ]
        }
    }
}
```

### Windows Example
```json
{
    "mcpServers": {
        "zep-cloud": {
            "command": "C:\\Python39\\python.exe",
            "args": [
                "C:\\Users\\username\\projects\\mcp-zep-cloud-server\\zep_cloud_server.py"
            ]
        }
    }
}
```

## Verify Setup

1. Make sure your `.env` file is properly set up with your Zep API Key
2. Run the test script to verify Zep Cloud connectivity:
   ```
   ./run_server.sh
   ```
   or on Windows:
   ```
   run_server.bat
   ```
3. Look for the tools in Claude Desktop (hammer icon should appear)
4. Try using the tools with a simple command like "List all users in Zep Cloud"

## Still Having Issues?

Check the Claude Desktop logs for more detailed error messages. Common issues include:

1. Python path incorrect
2. Server script path incorrect 
3. Missing or invalid Zep API Key
4. Python dependencies not installed

If you continue to have problems, please refer to the troubleshooting section in the README or contact support. 

## Security Considerations

### Protecting Your API Keys

The MCP Server requires access to your Zep Cloud API key. Follow these security best practices:

1. **Store API keys in the .env file only**
   - Never hardcode API keys in your Python code
   - Never include API keys in the `claude_desktop_config.json` file
   - The `.env` file should be kept out of version control (it's in .gitignore)

2. **Before first commit**
   - Make sure the `.gitignore` file is committed FIRST
   - Run our security check script to verify your setup:
     ```bash
     # On macOS/Linux
     ./scripts/check_security.sh
     
     # On Windows
     scripts\check_security.bat
     ```

3. **API key rotation**
   - Periodically rotate your Zep Cloud API keys
   - Update your `.env` file after generating a new key

### Repository Safety

If you're planning to fork or extend this project, carefully review the [SECURITY.md](SECURITY.md) file for comprehensive security guidelines. This contains important information about:
- Protecting sensitive information
- Safe development practices
- What to do if credentials are accidentally exposed

Remember: Never share API keys or sensitive credentials with others. Each developer should use their own API keys in their local environment. 


================================================
FILE: .env.example
================================================
# Zep Cloud API Key
# Get this from your Zep Cloud dashboard: https://app.getzep.com
ZEP_API_KEY=your_zep_api_key_here

# Optional: Zep Cloud API URL 
# Default is https://api.getzep.com/api/v2
# ZEP_CLOUD_API_URL=https://api.getzep.com/api/v2 


================================================
FILE: config/claude_desktop_config.json.example
================================================
{
    "mcpServers": {
        "zep-cloud": {
            "command": "/ABSOLUTE/PATH/TO/venv/bin/python",
            "args": [
                "/ABSOLUTE/PATH/TO/zep_cloud_server.py"
            ]
        }
    }
} 


================================================
FILE: config/requirements.txt
================================================
# Core MCP and FastMCP dependencies
mcp>=1.12.4
fastmcp>=2.11.2

# Zep Cloud SDK
zep-cloud>=3.2.0

# HTTP client libraries
httpx>=0.28.1
requests>=2.32.4

# Environment and configuration
python-dotenv>=1.1.1
pydantic>=2.11.7
pydantic-settings>=2.10.1

# Async support
anyio>=4.10.0

# Logging and CLI
rich>=14.1.0
click>=8.2.1

# Type checking and validation
typing-extensions>=4.14.1
annotated-types>=0.7.0

# JSON handling
jsonschema>=4.25.0



================================================
FILE: config/.env.example
================================================
# Zep Cloud API Key (get this from your Zep Cloud dashboard)
ZEP_API_KEY=your_zep_api_key_here

# The Zep Cloud API URL is set to https://api.getzep.com/api/v2 by default
# You should not need to change this unless instructed by Zep support 


================================================
FILE: core/run_server.py
================================================
#!/usr/bin/env python3
"""
Simple script to run the Zep Cloud server directly
"""

import os
import sys
import logging
from importlib import import_module

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger("ServerRunner")

def main():
    """Run the server"""
    logger.info("🚀 Starting the Zep Cloud server")
    
    try:
        # Import the server module
        server_module = import_module("zep_cloud_server")
        
        # Get the MCP instance
        if hasattr(server_module, "mcp"):
            mcp = server_module.mcp
            
            # Run the server on a specific host and port
            host = os.getenv("MCP_HOST", "0.0.0.0")
            port = int(os.getenv("MCP_PORT", "8080"))
            logger.info(f"🌐 Server running at http://{host}:{port}")
            
            # Run the server
            mcp.run()
        else:
            logger.error("❌ MCP instance not found in server module")
            sys.exit(1)
    
    except Exception as e:
        logger.error(f"❌ Failed to start server: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main() 


================================================
FILE: core/zep_cloud_client.py
================================================
#!/usr/bin/env python3
"""
Zep Cloud Client
This module provides a client for interacting with the Zep Cloud API
using the official Zep Cloud SDK.
"""

import os
import logging
from typing import Dict, List, Optional, Any, Union
import json
import requests

from dotenv import load_dotenv

# Import the Zep Cloud SDK
try:
    from zep_cloud.client import Zep
    from zep_cloud import User
except ImportError:
    raise ImportError(
        "zep-cloud SDK not found. Install with: pip install zep-cloud"
    )

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()

class ZepCloudClient:
    """Client for interacting with the Zep Cloud API"""
    
    def __init__(self):
        """Initialize the Zep Cloud client"""
        self.api_key = os.getenv("ZEP_API_KEY")
        self.fallback_mode = False
        
        if not self.api_key:
            logger.error("ZEP_API_KEY environment variable not set. Running in fallback mode.")
            self.fallback_mode = True
            return
        
        # Initialize the client
        try:
            self.client = Zep(api_key=self.api_key)
            logger.info("Zep Cloud client initialized successfully")
            # Test the connection by trying to list users
            self._test_connection()
        except Exception as e:
            logger.error(f"Failed to initialize Zep Cloud client: {str(e)}")
            logger.warning("Running in fallback mode.")
            self.fallback_mode = True
            
    def _test_connection(self):
        """Test the connection to Zep Cloud by making a simple API call"""
        try:
            # Try to list users as a connection test
            self.client.user.list_ordered()
            logger.info("✅ Connected to Zep Cloud API")
            self.fallback_mode = False
        except Exception as e:
            logger.warning(f"❌ Failed to connect to Zep Cloud API: {str(e)}")
            logger.warning("⚠️ Running in fallback mode")
            self.fallback_mode = True
        
    def list_users(self, limit: int = 100, cursor: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        List all users
        
        Returns:
            List[Dict[str, Any]]: List of user objects
        """
        if self.fallback_mode:
            logger.warning("⚠️ Running in fallback mode. User listing simulated.")
            return []
            
        try:
            user_response = self.client.user.list_ordered()
            users = user_response.users or []
            
            # Convert User objects to dictionaries
            user_dicts = []
            for user in users:
                user_dict = {
                    "user_id": user.user_id,
                    "metadata": user.metadata if user.metadata else {}
                }
                user_dicts.append(user_dict)
                
            return user_dicts
            
        except Exception as e:
            logger.error(f"Error listing users: {str(e)}")
            return []
            
    def get_user(self, user_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a user by ID
        
        Args:
            user_id (str): The user ID
            
        Returns:
            Optional[Dict[str, Any]]: User object if found, None otherwise
        """
        if self.fallback_mode:
            logger.warning("⚠️ Running in fallback mode. User retrieval simulated.")
            return {"user_id": user_id, "success": True, "fallback": True}
            
        try:
            user = self.client.user.get(user_id=user_id)
            
            if user:
                return {
                    "user_id": user.user_id,
                    "metadata": user.metadata if user.metadata else {},
                    "first_name": user.first_name,
                    "last_name": user.last_name,
                    "email": user.email
                }
            return None
            
        except Exception as e:
            logger.error(f"Error getting user {user_id}: {str(e)}")
            return None
            
    def create_user(self, user_id: str, metadata: Optional[Dict[str, Any]] = None, first_name: Optional[str] = None, last_name: Optional[str] = None, email: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """
        Create a new user
        
        Args:
            user_id (str): The user ID
            metadata (Optional[Dict[str, Any]]): User metadata
            first_name (Optional[str]): User's first name
            last_name (Optional[str]): User's last name
            email (Optional[str]): User's email address
            
        Returns:
            Optional[Dict[str, Any]]: Created user object if successful, None otherwise
        """
        if self.fallback_mode:
            logger.warning("⚠️ Running in fallback mode. User creation simulated.")
            return {
                "user_id": user_id, 
                "metadata": metadata or {}, 
                "first_name": first_name, 
                "last_name": last_name, 
                "email": email, 
                "success": True, 
                "fallback": True
            }
            
        try:
            # Ensure metadata is not None
            metadata_dict = metadata if metadata is not None else {}
            
            # Create the user
            user = self.client.user.add(
                user_id=user_id,
                metadata=metadata_dict,
                first_name=first_name,
                last_name=last_name,
                email=email
            )
            
            return {
                "user_id": user.user_id,
                "metadata": user.metadata if user.metadata else {},
                "first_name": user.first_name,
                "last_name": user.last_name,
                "email": user.email
            }
            
        except Exception as e:
            logger.error(f"Error creating user {user_id}: {str(e)}")
            return None
            
    def update_user(self, user_id: str, metadata: Optional[Dict[str, Any]] = None, first_name: Optional[str] = None, last_name: Optional[str] = None, email: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """
        Update a user's metadata and profile information
        
        Args:
            user_id (str): The user ID
            metadata (Optional[Dict[str, Any]]): User metadata
            first_name (Optional[str]): User's first name
            last_name (Optional[str]): User's last name 
            email (Optional[str]): User's email address
            
        Returns:
            Optional[Dict[str, Any]]: Updated user object if successful, None otherwise
        """
        if self.fallback_mode:
            logger.warning("⚠️ Running in fallback mode. User update simulated.")
            return {
                "user_id": user_id, 
                "metadata": metadata or {}, 
                "first_name": first_name, 
                "last_name": last_name, 
                "email": email, 
                "success": True, 
                "fallback": True
            }
            
        try:
            # Ensure metadata is not None
            metadata_dict = metadata if metadata is not None else {}
            
            # Update the user
            user = self.client.user.update(
                user_id=user_id,
                metadata=metadata_dict,
                first_name=first_name,
                last_name=last_name,
                email=email
            )
            
            return {
                "user_id": user.user_id,
                "metadata": user.metadata if user.metadata else {},
                "first_name": user.first_name,
                "last_name": user.last_name,
                "email": user.email
            }
            
        except Exception as e:
            logger.error(f"Error updating user {user_id}: {str(e)}")
            return None
            
    def delete_user(self, user_id: str) -> bool:
        """
        Delete a user
        
        Args:
            user_id (str): The user ID
            
        Returns:
            bool: True if successful, False otherwise
        """
        if self.fallback_mode:
            logger.warning("⚠️ Running in fallback mode. User deletion simulated.")
            return True
            
        try:
            self.client.user.delete(user_id=user_id)
            return True
            
        except Exception as e:
            logger.error(f"Error deleting user {user_id}: {str(e)}")
            return False
            
    def search_graph(self, user_id: str, query: str, limit: int = 10) -> Optional[Dict[str, Any]]:
        """
        Search the user's graph with a query
        
        Args:
            user_id (str): The user ID
            query (str): The search query
            limit (int): The maximum number of results to return
            
        Returns:
            Optional[Dict[str, Any]]: Search results if successful, None otherwise
        """
        if self.fallback_mode:
            logger.warning("⚠️ Running in fallback mode. Graph search simulated.")
            return {
                "query": query, 
                "user_id": user_id, 
                "limit": limit,
                "edges": [],
                "nodes": [],
                "results": [],  
                "success": True,
                "summary": "No results found for query (fallback mode)",
                "fallback": True
            }
            
        try:
            # Keep queries concise as recommended by docs
            if len(query) > 8000:
                logger.warning(f"Search query exceeds recommended length. Truncating to 8000 characters.")
                query = query[:8000]
                
            # Call the graph search API
            search_results = self.client.graph.search(
                user_id=user_id,
                query=query,
                limit=limit
            )
            
            # Create a digestible result that can be serialized to JSON
            results = {
                "query": query,
                "user_id": user_id,
                "limit": limit,
                "success": True,
                "results": []  # Keep generic results array for backward compatibility
            }
            
            # Add edges (facts) if they exist
            if hasattr(search_results, 'edges') and search_results.edges:
                results["edges"] = []
                for edge in search_results.edges:
                    edge_data = {
                        "id": edge.id if hasattr(edge, 'id') else None,
                        "fact": edge.fact if hasattr(edge, 'fact') else None,
                        "created_at": str(edge.created_at) if hasattr(edge, 'created_at') else None,
                        "updated_at": str(edge.updated_at) if hasattr(edge, 'updated_at') else None,
                        "score": edge.score if hasattr(edge, 'score') else None
                    }
                    results["edges"].append(edge_data)
                    # Also add to generic results for backward compatibility
                    results["results"].append(edge_data)
            
            # Add nodes if they exist
            if hasattr(search_results, 'nodes') and search_results.nodes:
                results["nodes"] = []
                for node in search_results.nodes:
                    node_data = {
                        "id": node.id if hasattr(node, 'id') else None,
                        "label": node.label if hasattr(node, 'label') else None,
                        "attributes": node.attributes if hasattr(node, 'attributes') else {},
                        "score": node.score if hasattr(node, 'score') else None
                    }
                    results["nodes"].append(node_data)
                    # Also add to generic results for backward compatibility
                    results["results"].append(node_data)
            
            # Add a summary field to help Claude understand the results
            if len(results["results"]) > 0:
                results["summary"] = f"Found {len(results['results'])} results for query '{query}'"
                if "nodes" in results and len(results["nodes"]) > 0:
                    results["summary"] += f", including {len(results['nodes'])} nodes"
                if "edges" in results and len(results["edges"]) > 0:
                    results["summary"] += f", including {len(results['edges'])} edges/facts"
            else:
                results["summary"] = f"No results found for query '{query}'"
            
            return results
            
        except Exception as e:
            logger.error(f"Error searching graph for user {user_id}: {str(e)}")
            return None
            
    def add_graph_data(self, user_id, data, data_type="text"):
        """
        Add data to a user's graph in Zep Cloud.
        
        Args:
            user_id: The unique identifier for the user
            data: The data to add to the graph (string or dict)
            data_type: The type of data, can be "text", "json", or "message"
            
        Returns:
            A dictionary with information about the added data
        """
        if not user_id:
            return {"error": "User ID is required", "success": False}
        
        if data is None:
            return {"error": "Data is required", "success": False}
        
        valid_types = ["text", "json", "message"]
        if data_type not in valid_types:
            return {
                "error": f"Invalid data type: {data_type}. Must be one of {valid_types}",
                "success": False
            }
            
        if self.fallback_mode:
            logger.warning("⚠️ Running in fallback mode. Graph data addition simulated.")
            return {
                "success": True,
                "user_id": user_id,
                "data_type": data_type,
                "data_length": len(str(data)),
                "fallback": True,
                "response": {
                    "uuid": "simulated-uuid",
                    "content": "Simulated content (fallback mode)",
                    "created_at": "simulated-timestamp",
                    "processed": True
                }
            }
        
        # Convert dict to JSON string if needed
        if data_type == "json" and isinstance(data, dict):
            try:
                data = json.dumps(data)
                logging.info(f"Converted Python dict to JSON string: {type(data)}")
            except Exception as e:
                return {
                    "error": f"Error converting dict to JSON: {str(e)}",
                    "success": False
                }
        
        # Check data size limits (after possible conversion)
        data_len = len(data) if isinstance(data, str) else len(str(data))
        if data_len > 100000:  # 100KB limit
            return {
                "error": f"Data size of {data_len} bytes exceeds 100KB limit",
                "success": False
            }
        
        # Additional validation for JSON data
        if data_type == "json":
            try:
                # Verify it's valid JSON
                if isinstance(data, str):
                    try:
                        json_data = json.loads(data)
                    except json.JSONDecodeError as e:
                        # Check for JSON with extra quotes
                        if data.startswith('"') and data.endswith('"') and len(data) > 2:
                            try:
                                # Try to parse the inner content without outer quotes
                                inner_data = data[1:-1]
                                if inner_data.lstrip().startswith(('{', '[')):
                                    json_data = json.loads(inner_data)
                                    data = inner_data
                                    logging.info(f"Fixed JSON by removing outer quotes: {type(json_data)}")
                                else:
                                    raise e
                            except Exception:
                                # If that didn't work, re-raise the original error
                                raise e
                        else:
                            raise e
                else:
                    # If already a dict or other Python object, convert to JSON string
                    json_data = data
                    data = json.dumps(data)
                
                # If we get here, data is valid JSON
                logging.info(f"Validated JSON data: {type(json_data)}")
            except json.JSONDecodeError as e:
                return {
                    "error": f"Invalid JSON data: {str(e)}",
                    "success": False
                }
            except Exception as e:
                return {
                    "error": f"Error processing JSON data: {str(e)}",
                    "success": False
                }
        
        # Use the Zep SDK to add the data to the graph
        try:
            # Call the graph add API
            response = self.client.graph.add(
                user_id=user_id,
                type=data_type,
                data=data
            )
            
            # Create a return value that can be serialized to JSON
            result = {
                "success": True,
                "user_id": user_id,
                "data_type": data_type,
                "data_length": len(data),
                "response": {
                    "uuid": response.uuid if hasattr(response, 'uuid') else None,
                    "content": response.content if hasattr(response, 'content') else None,
                    "created_at": str(response.created_at) if hasattr(response, 'created_at') else None,
                    "processed": response.processed if hasattr(response, 'processed') else None
                }
            }
            
            return result
            
        except Exception as e:
            error_message = f"Exception adding graph data: {str(e)}"
            logging.error(error_message)
            return {
                "error": error_message,
                "success": False
            } 


================================================
FILE: core/zep_cloud_server.py
================================================
#!/usr/bin/env python3
"""
MCP Server for Zep Cloud
This server provides tools for Claude Desktop to interact with Zep Cloud API.
"""

import os
import json
import sys
import logging
import requests
import socket
from dotenv import load_dotenv
from fastmcp import FastMCP
from typing import Optional, Dict, Any, Union

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger("ZepCloudServer")

# Load environment variables
load_dotenv()

# Initialize FastMCP
mcp = FastMCP()

# Track the number of tools registered
tool_count = 0

# Import our ZepCloudClient or use the local implementation as fallback
try:
    # First try to import from the core directory
    sys.path.append(os.path.dirname(os.path.abspath(__file__)))
    from zep_cloud_client import ZepCloudClient
    logger.info("✅ Imported ZepCloudClient from zep_cloud_client.py")
    use_new_client = True
except ImportError:
    logger.warning("⚠️ Failed to import ZepCloudClient from zep_cloud_client.py. Using local implementation.")
    use_new_client = False
    
    # ZEP API Configuration if using local implementation
    ZEP_API_KEY = os.getenv("ZEP_API_KEY")
    ZEP_CLOUD_API_URL = "https://api.getzep.com/api/v2"

# If using the old client implementation, define it here
if not use_new_client:
    class ZepCloudClient:
        """Client for interacting with the Zep Cloud API."""

        def __init__(self, api_key=None, api_url=None):
            """Initialize the client with API key and URL."""
            self.api_key = api_key or ZEP_API_KEY
            self.api_url = api_url or ZEP_CLOUD_API_URL
            self.headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {self.api_key}"
            }
            self.fallback_mode = False
            self.test_connection()

        def test_connection(self):
            """Test the connection to the Zep Cloud API."""
            try:
                response = self._make_request("GET", f"{self.api_url}/health")
                if response.status_code == 200:
                    logger.info("✅ Connected to Zep Cloud API")
                    self.fallback_mode = False
                    return True
                else:
                    logger.warning(f"❌ Zep Cloud API authentication failed: {response.status_code} - {response.text}")
                    self.fallback_mode = True
                    return False
            except Exception as e:
                logger.error(f"❌ Failed to connect to Zep Cloud API: {str(e)}")
                self.fallback_mode = True
                return False

        def _handle_request_error(self, e, context_msg):
            """Handle request errors with detailed logging and diagnostics."""
            if isinstance(e, requests.exceptions.ConnectionError):
                # Check if it's a DNS resolution error
                if isinstance(e.args[0], socket.gaierror):
                    logger.error(f"❌ DNS resolution error during {context_msg}. Check your internet connection and API URL.")
                else:
                    logger.error(f"❌ Connection error during {context_msg}: {str(e)}")
            elif isinstance(e, requests.exceptions.HTTPError):
                status_code = e.response.status_code
                error_text = e.response.text

                if status_code == 401:
                    logger.error(f"❌ Authentication error during {context_msg}. Check your ZEP_API_KEY.")
                elif status_code == 404:
                    logger.error(f"❌ Resource not found during {context_msg}. Check the API endpoint.")
                else:
                    logger.error(f"❌ HTTP error {status_code} during {context_msg}: {error_text}")
            else:
                logger.error(f"❌ Error during {context_msg}: {str(e)}")

        def _make_request(self, method, url, data=None):
            """Make a request to the Zep Cloud API."""
            try:
                response = requests.request(method, url, headers=self.headers, json=data)
                response.raise_for_status()
                return response
            except Exception as e:
                self._handle_request_error(e, f"{method} request to {url}")
                raise

        def create_user(self, user_id: str, metadata: Optional[dict] = None, first_name: Optional[str] = None, last_name: Optional[str] = None, email: Optional[str] = None):
            """Create a new user in Zep Cloud."""
            # Handle case where metadata is the string "null"
            if metadata == "null":
                metadata = None
                
            if self.fallback_mode:
                logger.warning("⚠️ Running in fallback mode. User creation simulated.")
                return {"user_id": user_id, "metadata": metadata or {}, "first_name": first_name, "last_name": last_name, "email": email, "success": True, "fallback": True}
                
            url = f"{self.api_url}/users"
            data = {"user_id": user_id}
            
            if metadata:
                data["metadata"] = metadata
            
            if first_name:
                data["first_name"] = first_name
                
            if last_name:
                data["last_name"] = last_name
            
            if email:
                data["email"] = email
            
            try:
                response = self._make_request("POST", url, data)
                return response.json()
            except Exception as e:
                logger.error(f"❌ Failed to create user: {str(e)}")
                return {"error": str(e), "success": False}

        def get_user(self, user_id):
            """Get a user from Zep Cloud."""
            if self.fallback_mode:
                logger.warning("⚠️ Running in fallback mode. User retrieval simulated.")
                return {"user_id": user_id, "success": True, "fallback": True}
                
            url = f"{self.api_url}/users/{user_id}"
            
            try:
                response = self._make_request("GET", url)
                return response.json()
            except Exception as e:
                logger.error(f"❌ Failed to get user: {str(e)}")
                return {"error": str(e), "success": False}

        def update_user(self, user_id, metadata):
            """Update a user in Zep Cloud."""
            # Handle case where metadata is the string "null"
            if metadata == "null":
                metadata = None
                
            if self.fallback_mode:
                logger.warning("⚠️ Running in fallback mode. User update simulated.")
                return {"user_id": user_id, "metadata": metadata or {}, "success": True, "fallback": True}
                
            url = f"{self.api_url}/users/{user_id}"
            data = {"metadata": metadata or {}}
            
            try:
                response = self._make_request("PATCH", url, data)
                return response.json()
            except Exception as e:
                logger.error(f"❌ Failed to update user: {str(e)}")
                return {"error": str(e), "success": False}

        def delete_user(self, user_id):
            """Delete a user from Zep Cloud."""
            if self.fallback_mode:
                logger.warning("⚠️ Running in fallback mode. User deletion simulated.")
                return {"success": True, "fallback": True}
                
            url = f"{self.api_url}/users/{user_id}"
            
            try:
                response = self._make_request("DELETE", url)
                return {"success": True}
            except Exception as e:
                logger.error(f"❌ Failed to delete user: {str(e)}")
                return {"error": str(e), "success": False}

        def list_users(self, limit: int = 100, cursor: Optional[str] = None):
            """List users in Zep Cloud."""
            if self.fallback_mode:
                logger.warning("⚠️ Running in fallback mode. User listing simulated.")
                return {"users": [], "success": True, "fallback": True}
                
            url = f"{self.api_url}/users?limit={limit}"
            if cursor:
                url += f"&cursor={cursor}"
            
            try:
                response = self._make_request("GET", url)
                return response.json()
            except Exception as e:
                logger.error(f"❌ Failed to list users: {str(e)}")
                return {"error": str(e), "success": False}

        def search_graph(self, user_id: str, query: str, limit: int = 10):
            """
            Search a user's graph in Zep Cloud.
            
            Args:
                user_id: The unique identifier for the user
                query: The search query to find relevant information about the user
                limit: The maximum number of results to return (default: 10)
                
            Returns:
                A JSON object with the search results including facts and/or nodes about the user
            """
            if self.fallback_mode:
                logger.warning("⚠️ Running in fallback mode. Graph search simulated.")
                return {
                    "query": query, 
                    "user_id": user_id, 
                    "limit": limit,
                    "edges": [],
                    "nodes": [],
                    "results": [],  # Include generic results array for backward compatibility
                    "success": True,
                    "summary": "No results found for query (fallback mode)",
                    "fallback": True
                }
                
            url = f"{self.api_url}/graph/search"
            data = {
                "user_id": user_id,
                "query": query,
                "limit": limit
            }
            
            try:
                response = self._make_request("POST", url, data)
                response_json = response.json()
                
                # Enhance response for better compatibility
                if "results" not in response_json:
                    response_json["results"] = []
                    
                    # Copy any edges or nodes to results array for backward compatibility
                    if "edges" in response_json and response_json["edges"]:
                        for edge in response_json["edges"]:
                            response_json["results"].append(edge)
                            
                    if "nodes" in response_json and response_json["nodes"]:
                        for node in response_json["nodes"]:
                            response_json["results"].append(node)
                
                # Add success flag
                response_json["success"] = True
                
                # Add a summary field to help Claude understand the results
                if len(response_json.get("results", [])) > 0:
                    response_json["summary"] = f"Found {len(response_json['results'])} results for query '{query}'"
                    if "nodes" in response_json and response_json["nodes"]:
                        response_json["summary"] += f", including {len(response_json['nodes'])} nodes"
                    if "edges" in response_json and response_json["edges"]:
                        response_json["summary"] += f", including {len(response_json['edges'])} edges/facts"
                else:
                    response_json["summary"] = f"No results found for query '{query}'"
                
                return response_json
            except Exception as e:
                logger.error(f"❌ Failed to search graph: {str(e)}")
                return {
                    "error": str(e), 
                    "success": False,
                    "summary": f"Error searching graph: {str(e)}"
                }
                
        def add_graph_data(self, user_id: str, data: str, data_type: str):
            """
            Add data to a user's graph in Zep Cloud.
            
            Args:
                user_id: The unique identifier for the user
                data: The data to add to the graph (text, JSON, or message)
                data_type: The type of data, can be "text", "json", or "message"
                
            Returns:
                A JSON object with information about the added data
            """
            if self.fallback_mode:
                logger.warning("⚠️ Running in fallback mode. Graph data addition simulated.")
                return {
                    "success": True,
                    "user_id": user_id,
                    "data_type": data_type,
                    "data_length": len(data),
                    "fallback": True,
                    "response": {
                        "uuid": "simulated-uuid",
                        "content": "Simulated content (fallback mode)",
                        "created_at": "simulated-timestamp",
                        "processed": True
                    }
                }
                
            # Check if data exceeds size limit
            if len(data) > 10000:
                logger.warning(f"Data exceeds maximum size of 10,000 characters. Truncating to 10,000 characters.")
                data = data[:10000]
                
            # Validate data type
            valid_types = ["text", "json", "message"]
            if data_type not in valid_types:
                logger.error(f"Invalid data type: {data_type}. Must be one of {valid_types}")
                return {
                    "error": f"Invalid data type: {data_type}. Must be one of {valid_types}",
                    "success": False
                }
                
            url = f"{self.api_url}/graph"
            post_data = {
                "user_id": user_id,
                "type": data_type,
                "data": data
            }
            
            try:
                response = self._make_request("POST", url, post_data)
                response_json = response.json()
                
                # Add success flag and additional info
                result = {
                    "success": True,
                    "user_id": user_id,
                    "data_type": data_type,
                    "data_length": len(data),
                    "response": response_json
                }
                
                return result
            except Exception as e:
                logger.error(f"❌ Failed to add data to graph: {str(e)}")
                return {
                    "error": str(e),
                    "success": False
                }

# Create a global client instance
try:
    client = ZepCloudClient()
    if hasattr(client, 'fallback_mode'):
        fallback_mode = client.fallback_mode
    else:
        # Check if connection works
        test_users = client.list_users()
        fallback_mode = test_users is None or len(test_users) == 0
        
    if fallback_mode:
        logger.warning("⚠️ Zep Cloud client is running in fallback mode. Operations will be simulated.")
    else:
        logger.info("✅ Zep Cloud client is connected and ready.")
        
except Exception as e:
    logger.error(f"❌ Failed to initialize Zep Cloud client: {str(e)}")
    logger.warning("⚠️ Falling back to simulation mode.")
    fallback_mode = True

# === Tool Definitions ===

@mcp.tool()
def create_user(user_id: str, metadata: Optional[dict] = None, first_name: Optional[str] = None, last_name: Optional[str] = None, email: Optional[str] = None):
    """
    Create a new user in Zep Cloud.
    
    Args:
        user_id: The unique identifier for the user
        metadata: Optional metadata for the user
        first_name: Optional first name for the user
        last_name: Optional last name for the user
        email: Optional email address for the user
        
    Returns:
        A JSON object with the user information
    """
    global tool_count
    tool_count += 1
    logger.info(f"📝 Tool call {tool_count}: create_user({user_id}, {metadata}, {first_name}, {last_name}, {email})")
    
    # Handle case where metadata is the string "null"
    if metadata == "null":
        metadata = None
        
    result = client.create_user(user_id, metadata, first_name, last_name, email)
    return json.dumps(result)

@mcp.tool()
def get_user(user_id: str):
    """
    Get a user from Zep Cloud.
    
    Args:
        user_id: The unique identifier for the user
        
    Returns:
        A JSON object with the user information
    """
    global tool_count
    tool_count += 1
    logger.info(f"📝 Tool call {tool_count}: get_user({user_id})")
    
    result = client.get_user(user_id)
    return json.dumps(result)

@mcp.tool()
def update_user(user_id: str, metadata: dict):
    """
    Update a user in Zep Cloud.
    
    Args:
        user_id: The unique identifier for the user
        metadata: The new metadata for the user
        
    Returns:
        A JSON object with the updated user information
    """
    global tool_count
    tool_count += 1
    logger.info(f"📝 Tool call {tool_count}: update_user({user_id}, {metadata})")
    
    # Handle case where metadata is the string "null"
    if metadata == "null":
        metadata = None
        
    result = client.update_user(user_id, metadata)
    return json.dumps(result)

@mcp.tool()
def delete_user(user_id: str):
    """
    Delete a user from Zep Cloud.
    
    Args:
        user_id: The unique identifier for the user
        
    Returns:
        A JSON object indicating success or failure
    """
    global tool_count
    tool_count += 1
    logger.info(f"📝 Tool call {tool_count}: delete_user({user_id})")
    
    result = client.delete_user(user_id)
    return json.dumps(result)

@mcp.tool()
def list_users(limit: int = 100, cursor: Optional[str] = None):
    """
    List users in Zep Cloud.
    
    Args:
        limit: The maximum number of users to return
        cursor: A cursor for pagination
        
    Returns:
        A JSON object with the list of users
    """
    global tool_count
    tool_count += 1
    logger.info(f"📝 Tool call {tool_count}: list_users({limit}, {cursor})")
    
    result = client.list_users(limit, cursor)
    return json.dumps(result)

@mcp.tool()
def check_connection():
    """
    Check the connection to the Zep Cloud API.
    
    Returns:
        A JSON object indicating connection status
    """
    global tool_count
    tool_count += 1
    logger.info(f"📝 Tool call {tool_count}: check_connection()")
    
    global fallback_mode
    result = {
        "connected": not fallback_mode,
        "fallback_mode": fallback_mode,
        "message": "Connected to Zep Cloud API" if not fallback_mode else "Running in fallback mode"
    }
    return json.dumps(result)

@mcp.tool()
def search_graph(user_id: str, query: str, limit: int = 10):
    """
    Search a user's graph in Zep Cloud.
    
    Args:
        user_id: The unique identifier for the user
        query: The search query to find relevant information about the user
        limit: The maximum number of results to return (default: 10)
        
    Returns:
        A JSON object with the search results including facts and/or nodes about the user
    """
    global tool_count
    tool_count += 1
    logger.info(f"📝 Tool call {tool_count}: search_graph({user_id}, {query}, {limit})")
    
    # Truncate very long queries
    if len(query) > 8000:
        logger.warning(f"Search query exceeds recommended length. Truncating to 8000 characters.")
        query = query[:8000]
    
    # If query seems to be about user information, emotions, or general data,
    # we know these provide better results
    lower_query = query.lower()
    if not query or len(query.strip()) == 0:
        query = "user information"
        logger.info(f"Empty query detected, using 'user information' instead")
    elif "user" not in lower_query and "information" not in lower_query and "data" not in lower_query:
        # Add "user information" to the query if it doesn't already contain similar terms
        enriched_query = f"{query} user information"
        logger.info(f"Enriching query to: {enriched_query}")
        query = enriched_query
    
    result = client.search_graph(user_id, query, limit)
    
    # Log the result structure for debugging
    result_info = {}
    if isinstance(result, dict):
        if "edges" in result and result["edges"]:
            result_info["edges_count"] = len(result["edges"])
        else:
            result_info["edges_count"] = 0
            
        if "nodes" in result and result["nodes"]:
            result_info["nodes_count"] = len(result["nodes"])
        else:
            result_info["nodes_count"] = 0
            
        if "results" in result and result["results"]:
            result_info["results_count"] = len(result["results"])
        else:
            result_info["results_count"] = 0
            
        logger.info(f"🔍 Search results: {result_info}")
    
    # Final result string that Claude can understand
    json_result = json.dumps(result)
    return json_result

@mcp.tool()
def add_graph_data(user_id: str, data: Union[str, dict], data_type: str):
    """
    Add data to a user's graph in Zep Cloud.
    
    Args:
        user_id: The unique identifier for the user
        data: The data to add to the graph (string or JSON object)
        data_type: The type of data, can be "text", "json", or "message"
        
    Returns:
        A JSON object with information about the added data
    """
    global tool_count
    tool_count += 1
    logger.info(f"📝 Tool call {tool_count}: add_graph_data({user_id}, [data length: {len(str(data))}], {data_type})")
    
    # Handle case where data is a Python dict instead of a string (Claude sometimes does this)
    if not isinstance(data, str) and data_type == "json":
        try:
            # Convert to string if it's a dict
            logger.info(f"Converting Python dict to JSON string")
            data = json.dumps(data)
        except Exception as e:
            error_msg = f"Failed to convert Python dict to JSON string: {str(e)}"
            logger.error(f"❌ {error_msg}")
            result = {
                "error": error_msg,
                "success": False
            }
            return json.dumps(result)
    
    # Validate data type
    valid_types = ["text", "json", "message"]
    if data_type not in valid_types:
        error_msg = f"Invalid data type: {data_type}. Must be one of {valid_types}"
        logger.error(f"❌ {error_msg}")
        result = {
            "error": error_msg,
            "success": False
        }
        return json.dumps(result)
    
    # Special handling for JSON data to make it more robust
    if data_type == "json":
        try:
            # If it's already JSON, this will validate it
            json.loads(data)
            logger.info(f"✅ Valid JSON data format detected")
        except json.JSONDecodeError:
            logger.warning(f"⚠️ Invalid JSON format detected. Attempting to fix...")
            
            # Try to fix common issues with JSON that Claude might introduce
            try:
                # Remove extra quotes that Claude might add
                if data.startswith("'") and data.endswith("'"):
                    data = data[1:-1]
                    logger.info("Removed outer single quotes")
                elif data.startswith('"') and data.endswith('"') and len(data) > 2:
                    # Check if this might be a JSON string with extra quotes
                    try:
                        # Try to parse without the outer quotes
                        inner_data = data[1:-1]
                        # If inner_data starts with { or [, it's likely a JSON object with extra quotes
                        if inner_data.lstrip().startswith(('{', '[')):
                            json.loads(inner_data)
                            # If we get here, the inner content is valid JSON
                            data = inner_data
                            logger.info("Removed outer double quotes from JSON string")
                    except Exception:
                        # If that didn't work, continue with other fixes
                        pass
                
                # Handle multi-line formatted JSON that Claude might provide
                data = data.strip()
                
                # Try to parse as Python literal if it looks like a dict
                if data.startswith('{') and data.endswith('}'):
                    try:
                        import ast
                        parsed_data = ast.literal_eval(data)
                        data = json.dumps(parsed_data)
                        logger.info("Fixed JSON using ast.literal_eval")
                    except Exception as e:
                        logger.warning(f"Could not parse as Python literal: {str(e)}")
                
                # Final validation of the fixed JSON
                try:
                    json.loads(data)
                    logger.info("✅ Successfully fixed JSON format")
                except json.JSONDecodeError as e:
                    logger.error(f"❌ Failed to fix JSON format: {str(e)}")
                    result = {
                        "error": f"Invalid JSON format: {str(e)}",
                        "success": False
                    }
                    return json.dumps(result)
            except Exception as e:
                logger.error(f"❌ Error trying to fix JSON format: {str(e)}")
                result = {
                    "error": f"Failed to process JSON data: {str(e)}",
                    "success": False
                }
                return json.dumps(result)
    
    # Call the client method
    try:
        result = client.add_graph_data(user_id, data, data_type)
        
        # Log summary based on result
        if isinstance(result, dict) and result.get("success"):
            uuid = result.get("response", {}).get("uuid", "unknown")
            logger.info(f"✅ Successfully added data to graph for user {user_id}, data type: {data_type}, UUID: {uuid}")
        else:
            error = result.get("error", "Unknown error") if isinstance(result, dict) else "Unknown error"
            logger.error(f"❌ Failed to add data to graph for user {user_id}: {error}")
        
        return json.dumps(result)
    except Exception as e:
        logger.error(f"❌ Exception adding data to graph: {str(e)}")
        import traceback
        traceback.print_exc()
        result = {
            "error": str(e),
            "success": False
        }
        return json.dumps(result)

# === Main Entry Point ===

if __name__ == "__main__":
    # Log successful startup
    logger.info("🚀 Starting Zep Cloud MCP Server")
    logger.info(f"📡 Connection Status: {'✅ Connected' if not fallback_mode else '⚠️ Fallback Mode'}")
    
    # Start the server
    mcp.run()



================================================
FILE: scripts/README.md
================================================
# MCP Server Wrapper Scripts

This directory contains cross-platform wrapper scripts to run the Zep Cloud MCP Server.

## Available Scripts

### Unix/Linux/macOS: `mcp_wrapper.sh`
```bash
# Make executable
chmod +x scripts/mcp_wrapper.sh

# Run the MCP server
./scripts/mcp_wrapper.sh
```

### Windows: `mcp_wrapper.bat`
```cmd
# Run the MCP server
scripts\mcp_wrapper.bat
```

## Features

- **Cross-platform compatibility**: Works on Windows, macOS, and Linux
- **Automatic virtual environment detection**: Looks for `venv/` or `.venv/` directories
- **Relative path resolution**: No hardcoded paths, works from any location
- **Proper working directory**: Changes to project root for correct imports
- **Error handling**: Graceful fallback to system Python if venv not found

## How It Works

1. **Path Resolution**: Scripts automatically detect their location and find the project root
2. **Virtual Environment**: Automatically activates Python virtual environment if found
3. **Working Directory**: Changes to project root to ensure imports work correctly
4. **Execution**: Runs the MCP server with all passed arguments

## Usage in Claude Desktop Config

### macOS/Linux
```json
{
  "mcpServers": {
    "zep-cloud": {
      "command": "/full/path/to/mcp-server-zep-cloud/scripts/mcp_wrapper.sh",
      "env": {
        "ZEP_API_KEY": "your-zep-api-key"
      }
    }
  }
}
```

### Windows
```json
{
  "mcpServers": {
    "zep-cloud": {
      "command": "C:\\full\\path\\to\\mcp-server-zep-cloud\\scripts\\mcp_wrapper.bat",
      "env": {
        "ZEP_API_KEY": "your-zep-api-key"
      }
    }
  }
}
```

## Troubleshooting

- Ensure the scripts have execute permissions on Unix systems
- Make sure Python and required dependencies are installed:
  ```bash
  pip install -r config/requirements.txt
  ```
- Check that the ZEP_API_KEY environment variable is set in `.env` file
- Verify the virtual environment exists (run `python -m venv venv` if needed)
- Copy `.env.example` to `.env` and configure your ZEP_API_KEY



================================================
FILE: scripts/check_security.bat
================================================
@echo off
REM Script to check for security issues before committing on Windows

echo [92m Checking repository for security issues...[0m

REM Navigate to the repository root
cd /d "%~dp0\.."

REM Check if .gitignore exists
if not exist .gitignore (
    echo [91m ERROR: .gitignore file does not exist![0m
    echo     Please create a .gitignore file first before adding any code.
    exit /b 1
) else (
    echo [92m .gitignore file exists[0m
)

REM Check if .env file exists with real API key
if exist .env (
    findstr /C:"ZEP_API_KEY=z_" .env >nul
    if not errorlevel 1 (
        echo [93m WARNING: .env file appears to contain a real API key[0m
        echo     This is fine for local development but should never be committed.
        echo     Verify that .env is in your .gitignore file.
    ) else (
        echo [92m .env file exists but doesn't seem to contain a real API key[0m
        echo     Remember to add your actual API key to this file.
    )
) else (
    echo [93m WARNING: No .env file found[0m
    echo     Please create a .env file from .env.example and add your API key.
)

REM Check if claude_desktop_config.json is properly configured
if exist claude_desktop_config.json (
    findstr /C:"ZEP_API_KEY" claude_desktop_config.json >nul
    if not errorlevel 1 (
        echo [91m ERROR: claude_desktop_config.json contains API key references[0m
        echo     Please remove API key references from claude_desktop_config.json.
        echo     API keys should only be stored in .env file.
    ) else (
        echo [92m claude_desktop_config.json exists and doesn't contain API keys[0m
    )
)

REM Check for Git status
where git >nul 2>nul
if %ERRORLEVEL% EQU 0 (
    if exist .git (
        echo [92m Git is initialized in this repository[0m
        echo     Remember to run 'git status --ignored' before your first commit
        echo     to verify sensitive files are being ignored.
    ) else (
        echo [93m WARNING: Git is not initialized in this directory[0m
        echo     Initialize Git with 'git init' before adding any files.
    )
) else (
    echo [93m WARNING: Git is not installed or not in your PATH[0m
    echo     Install Git to use version control with this repository.
)

echo.
echo [92m Security check completed![0m
echo Remember: Never commit API keys or sensitive information to version control.
echo If this is your first time setting up the repository, make sure to:
echo 1. Commit .gitignore FIRST before any other files
echo 2. Make sure your .env file and other sensitive files are being ignored
echo 3. Follow the security guidelines in SECURITY.md
echo. 


================================================
FILE: scripts/check_security.sh
================================================
#!/bin/bash
# Script to check for security issues before committing

echo "🔒 Checking repository for security issues..."

# Navigate to the repository root
cd "$(dirname "$0")/.."
ROOT_DIR=$(pwd)

# Check if .gitignore exists
if [ ! -f ".gitignore" ]; then
    echo "❌ ERROR: .gitignore file does not exist!"
    echo "    Please create a .gitignore file first before adding any code."
    exit 1
else
    echo "✅ .gitignore file exists"
fi

# Check if .env is being ignored
if grep -q "^\.env$" .gitignore; then
    echo "✅ .env is properly configured in .gitignore"
else
    echo "❌ ERROR: .env is not configured in .gitignore!"
    echo "    Please add '.env' to your .gitignore file."
    exit 1
fi

# Check if .env file exists with real API key
if [ -f ".env" ]; then
    if grep -q "ZEP_API_KEY=z_" .env || grep -q "ZEP_API_KEY=sk-" .env || grep -q "ZEP_API_KEY=[a-zA-Z0-9_-]\{30,\}" .env; then
        echo "⚠️ WARNING: .env file appears to contain a real API key"
        echo "    This is fine for local development but should never be committed."
        echo "    Verify that .env is in your .gitignore file."
    else
        echo "✅ .env file exists but doesn't seem to contain a real API key"
        echo "    Remember to add your actual API key to this file."
    fi
else
    echo "⚠️ WARNING: No .env file found"
    echo "    Please create a .env file from .env.example and add your API key."
fi

# Check if claude_desktop_config.json is properly configured
if [ -f "claude_desktop_config.json" ]; then
    if grep -q "ZEP_API_KEY" claude_desktop_config.json; then
        echo "❌ ERROR: claude_desktop_config.json contains API key references"
        echo "    Please remove API key references from claude_desktop_config.json."
        echo "    API keys should only be stored in .env file."
    else
        echo "✅ claude_desktop_config.json exists and doesn't contain API keys"
    fi
fi

# Check for any hardcoded API keys in Python files
HARDCODED_KEYS=$(grep -r "ZEP_API_KEY\s*=\s*['\"]z_" --include="*.py" . | grep -v "os.getenv" || true)
if [ -n "$HARDCODED_KEYS" ]; then
    echo "❌ ERROR: Hardcoded API keys found in the following files:"
    echo "$HARDCODED_KEYS"
    echo "    Please remove hardcoded API keys and use environment variables instead."
    exit 1
else
    echo "✅ No hardcoded API keys found in Python files"
fi

# Check git status for any files that should be excluded
if command -v git &> /dev/null && [ -d ".git" ]; then
    IGNORED_FILES=$(git status --ignored | grep -E "\.env$|venv/|__pycache__|\.pyc$" || true)
    if [ -n "$IGNORED_FILES" ]; then
        echo "✅ Git is correctly ignoring sensitive files"
    else
        echo "⚠️ WARNING: Could not verify if Git is ignoring sensitive files"
        echo "    Make sure to run 'git status --ignored' before your first commit."
    fi
else
    echo "⚠️ WARNING: Git is not initialized in this directory"
    echo "    Initialize Git with 'git init' before adding any files."
fi

echo ""
echo "🔒 Security check completed!"
echo "Remember: Never commit API keys or sensitive information to version control."
echo "If this is your first time setting up the repository, make sure to:"
echo "1. Commit .gitignore FIRST before any other files"
echo "2. Make sure your .env file and other sensitive files are being ignored"
echo "3. Follow the security guidelines in SECURITY.md"
echo "" 


================================================
FILE: scripts/check_user_exists.py
================================================
#!/usr/bin/env python3
"""
Script to check if a specific user exists in Zep Cloud
"""

import os
import sys
import json
from pathlib import Path
from dotenv import load_dotenv

# Try loading from both .env and .env.new
env_path = Path('.env.new')
if env_path.exists():
    load_dotenv(dotenv_path=env_path)
    print(f"Loaded environment from .env.new")
else:
    load_dotenv()  # Fallback to default .env
    print(f"Loaded environment from .env")

# Import the Zep Cloud client
try:
    from zep_cloud_client import ZepCloudClient
    print("Successfully imported ZepCloudClient")
except ImportError:
    print("Failed to import ZepCloudClient. Make sure zep_cloud_client.py is in the current directory.")
    sys.exit(1)

def check_user_exists(user_id):
    """Check if a user exists in Zep Cloud"""
    print(f"\n=== Checking if user exists in Zep Cloud: {user_id} ===\n")
    
    # Create client
    try:
        client = ZepCloudClient()
        print(f"Successfully initialized ZepCloudClient")
    except Exception as e:
        print(f"Error initializing client: {str(e)}")
        return False
    
    # Check if user exists
    try:
        user = client.get_user(user_id)
        
        if user:
            print(f"✅ User exists: {user['user_id']}")
            print(f"Metadata: {json.dumps(user['metadata'], indent=2)}")
            return True
        else:
            print(f"❌ User {user_id} does not exist")
            return False
    except Exception as e:
        print(f"❌ Error checking user: {str(e)}")
        return False

if __name__ == "__main__":
    # Get user ID from command line or use default
    user_id = sys.argv[1] if len(sys.argv) > 1 else "16263830569_aprilx"
    check_user_exists(user_id) 


================================================
FILE: scripts/create_specific_user.py
================================================
#!/usr/bin/env python3
"""
Script to create a specific user in Zep Cloud with the ID "16263830569_aprilx"
This will attempt to create the user directly in the Zep Cloud API without fallback mode
"""

import os
import sys
import time
import json
from pathlib import Path
from dotenv import load_dotenv

# Try loading from both .env and .env.new
env_path = Path('.env.new')
if env_path.exists():
    load_dotenv(dotenv_path=env_path)
    print(f"Loaded environment from .env.new")
else:
    load_dotenv()  # Fallback to default .env
    print(f"Loaded environment from .env")

# Import the Zep Cloud client
try:
    from zep_cloud_client import ZepCloudClient
    print("Successfully imported ZepCloudClient")
except ImportError:
    print("Failed to import ZepCloudClient. Make sure zep_cloud_client.py is in the current directory.")
    sys.exit(1)

# The specific user ID we want to create
USER_ID = "16263830569_aprilx"

def main():
    print(f"\n=== Creating specific user in Zep Cloud: {USER_ID} ===\n")
    
    # Create client
    try:
        client = ZepCloudClient()
        print(f"Successfully initialized ZepCloudClient")
    except Exception as e:
        print(f"Error initializing client: {str(e)}")
        sys.exit(1)
    
    # Create user with metadata
    metadata = {
        "created_at": time.time(),
        "description": "Test user created for production use",
        "source": "direct_api_call",
        "organization": "zep_cloud_test"
    }
    
    print(f"Attempting to create user {USER_ID} with metadata:")
    print(json.dumps(metadata, indent=2))
    
    # Try to create the user
    try:
        user = client.create_user(USER_ID, metadata)
        
        if user:
            print(f"\n✅ SUCCESS: Created user: {user['user_id']}")
            print(f"Metadata: {json.dumps(user['metadata'], indent=2)}")
            print("\nThe user should now be available in the Zep Cloud system.")
            return True
        else:
            print(f"\n❌ ERROR: Failed to create user {USER_ID}")
            return False
    except Exception as e:
        print(f"\n❌ ERROR: Exception while creating user: {str(e)}")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1) 


================================================
FILE: scripts/mcp_wrapper.bat
================================================
@echo off
REM Zep Cloud MCP Server Wrapper Script for Windows
REM This script provides a portable way to run the Zep Cloud MCP Server on Windows

REM Get the directory where this script is located
set SCRIPT_DIR=%~dp0
for %%i in ("%SCRIPT_DIR%..") do set PROJECT_DIR=%%~fi

REM Check if virtual environment exists and activate it
if exist "%PROJECT_DIR%\venv\Scripts\activate.bat" (
    echo Activating virtual environment...
    call "%PROJECT_DIR%\venv\Scripts\activate.bat"
) else if exist "%PROJECT_DIR%\.venv\Scripts\activate.bat" (
    echo Activating virtual environment (.venv)...
    call "%PROJECT_DIR%\.venv\Scripts\activate.bat"
) else (
    echo Warning: No virtual environment found. Using system Python.
)

REM Change to project directory to ensure relative imports work
cd /d "%PROJECT_DIR%"

REM Run the MCP server
python "%PROJECT_DIR%\core\zep_cloud_server.py" %*



================================================
FILE: scripts/mcp_wrapper.sh
================================================
#!/bin/bash
# Zep Cloud MCP Server Wrapper Script
# This script provides a portable way to run the Zep Cloud MCP Server

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# Check if virtual environment exists and activate it
if [ -f "$PROJECT_DIR/venv/bin/activate" ]; then
    echo "Activating virtual environment..." >&2
    source "$PROJECT_DIR/venv/bin/activate"
elif [ -f "$PROJECT_DIR/.venv/bin/activate" ]; then
    echo "Activating virtual environment (.venv)..." >&2
    source "$PROJECT_DIR/.venv/bin/activate"
else
    echo "Warning: No virtual environment found. Using system Python." >&2
fi

# Change to project directory to ensure relative imports work
cd "$PROJECT_DIR"

# Run the MCP server
exec python "$PROJECT_DIR/core/zep_cloud_server.py" "$@"



================================================
FILE: scripts/run_server.bat
================================================
@echo off
REM Script to run the Zep Cloud MCP Server on Windows

REM Navigate to the repository root directory
cd /d "%~dp0\.."

REM Find Python path
FOR /F "tokens=*" %%g IN ('where python') do (SET PYTHON_PATH=%%g)

IF "%PYTHON_PATH%"=="" (
    echo Error: Python is not installed or not in PATH. Please install Python to run this server.
    exit /b 1
)

echo Using Python at: %PYTHON_PATH%

REM Check if .env file exists
if not exist .env (
    echo Warning: .env file not found. Creating from template...
    if exist config\.env.example (
        copy config\.env.example .env
        echo Created .env file from template. Please edit it to add your Zep API Key.
        echo You can run this script again after setting your API key.
        exit /b 1
    ) else (
        echo Error: .env.example template not found. Please create a .env file manually.
        echo It should contain: ZEP_API_KEY=your_api_key_here
        exit /b 1
    )
)

REM Install dependencies
echo Checking dependencies...
"%PYTHON_PATH%" -m pip install -r config\requirements.txt

REM Run the server
echo Starting Zep Cloud MCP Server...
fastmcp dev core\zep_cloud_server.py 


================================================
FILE: scripts/run_server.sh
================================================
#!/bin/bash
# Script to run the Zep Cloud MCP Server

# Navigate to the repository root directory
cd "$(dirname "$0")/.."

# Check if virtual environment exists, if not create it
if [ ! -d "venv" ]; then
    echo "Creating virtual environment..."
    python3 -m venv venv
    source venv/bin/activate
    pip install -r config/requirements.txt
else
    # Activate virtual environment
    source venv/bin/activate
fi

# Get the Python path from the virtual environment
PYTHON_PATH="$(which python)"
echo "Using Python at: $PYTHON_PATH"

# Check dependencies
echo "Checking dependencies..."
pip install -r config/requirements.txt

# Check if .env file exists
if [ ! -f ".env" ]; then
    echo "Creating example .env file..."
    if [ -f "config/.env.example" ]; then
        cp config/.env.example .env
        echo "Created .env from example file. Please edit it to add your Zep API Key."
    else
        echo "ZEP_API_KEY=" > .env
        echo "Created empty .env file. Please edit it to add your Zep API Key."
    fi
fi

# Run the server
echo "Starting Zep Cloud MCP Server..."

# Run the server in development mode using the file from the core directory
fastmcp dev core/zep_cloud_server.py 


================================================
FILE: scripts/test_claude_error.py
================================================
#!/usr/bin/env python3
"""
Script to test the exact scenario from the Claude error message
"""

import os
import sys
import json
from dotenv import load_dotenv

# Add the parent directory to the path so we can import the client
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Load environment variables
load_dotenv()

# Import the ZepCloudClient
from core.zep_cloud_server import add_graph_data

def test_claude_error_scenario():
    """Test the exact scenario that failed in Claude"""
    print("\n=== Testing Exact Claude Error Scenario ===")
    
    # This is the exact data structure from the error message
    user_id = "anthony_ant2"
    data = {
        "datetime": "2025-01-01T00:00:00Z", 
        "text": "Omg, today I had an orange pie and it was so good! I think I'm going to try baking orange pies from now on. Oh and I loved how crunchy it was."
    }
    data_type = "json"
    
    print(f"User ID: {user_id}")
    print(f"Data: {data}")
    print(f"Data Type: {data_type}")
    
    # Try calling the tool function directly
    try:
        result_json = add_graph_data(user_id, data, data_type)
        result = json.loads(result_json)
        
        success = result.get("success", False)
        print(f"\nResult: {'✅ Success' if success else '❌ Failure'}")
        if not success:
            print(f"Error: {result.get('error', 'Unknown error')}")
        else:
            print("✅ Successfully processed the exact error scenario data!")
            print(f"Response: {json.dumps(result, indent=2)}")
    except Exception as e:
        print(f"❌ Exception: {str(e)}")
    
    # Also try with a JSON-escaped string (which is what the error showed)
    print("\n== Testing with JSON-escaped string ==")
    escaped_json = '{\"datetime\": \"2025-01-01T00:00:00Z\", \"text\": \"Omg, today I had an orange pie and it was so good! I think I\\\'m going to try baking orange pies from now on. Oh and I loved how crunchy it was.\"}'
    
    try:
        result_json = add_graph_data(user_id, escaped_json, data_type)
        result = json.loads(result_json)
        
        success = result.get("success", False)
        print(f"Result: {'✅ Success' if success else '❌ Failure'}")
        if not success:
            print(f"Error: {result.get('error', 'Unknown error')}")
        else:
            print("✅ Successfully processed the escaped JSON data!")
    except Exception as e:
        print(f"❌ Exception with escaped JSON: {str(e)}")
    
    print("\n=== Test Complete ===")
    print("If both tests passed, the issue should be resolved!")

if __name__ == "__main__":
    test_claude_error_scenario() 


================================================
FILE: scripts/test_claude_json.py
================================================
#!/usr/bin/env python3
"""
Script to test JSON formatting issues that Claude might encounter
This simulates different ways Claude might format JSON data
"""

import os
import sys
import json
import time
from pathlib import Path
from dotenv import load_dotenv

# Try loading environment variables
env_path = Path('.env')
if env_path.exists():
    load_dotenv(dotenv_path=env_path)
    print(f"Loaded environment from .env")
else:
    load_dotenv()  # Fallback to default .env
    print(f"Loaded environment from .env")

# User ID to test with
USER_ID = "16263830569"

# Import the Zep Cloud client
try:
    # Try to import from the core directory
    sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from core.zep_cloud_client import ZepCloudClient
    print("Successfully imported ZepCloudClient")
except ImportError as e:
    print(f"Failed to import ZepCloudClient: {str(e)}")
    print("Make sure zep_cloud_client.py is accessible.")
    sys.exit(1)

def test_claude_json_handling():
    """Test various JSON formatting scenarios that Claude might use"""
    print(f"\n=== Testing Claude JSON Handling for user: {USER_ID} ===")
    
    # Create client
    try:
        client = ZepCloudClient()
        print(f"Successfully initialized ZepCloudClient")
    except Exception as e:
        print(f"Error initializing client: {str(e)}")
        sys.exit(1)
    
    # Test scenarios simulating how Claude might format JSON data
    test_scenarios = [
        {
            "name": "Standard JSON Object", 
            "json_data": {"name": "Test User", "age": 30, "active": True},
            "expected_success": True
        },
        {
            "name": "JSON with nested quotes", 
            "json_data": '{"name": "Test User", "message": "Hello, this is a \"quoted\" message"}',
            "expected_success": True,
            "is_string": True
        },
        {
            "name": "JSON with extra quotes",
            "json_data": '\'{"name": "Extra Quotes Test", "age": 30}\'',
            "expected_success": False,
            "is_string": True
        },
        {
            "name": "JSON with formatted string",
            "json_data": """
            {
                "name": "Formatted JSON",
                "description": "JSON with newlines and indentation",
                "items": [1, 2, 3]
            }
            """,
            "expected_success": True,
            "is_string": True
        },
        {
            "name": "JSON with escaped backslashes",
            "json_data": '{"path": "C:\\\\Users\\\\Documents"}',
            "expected_success": True,
            "is_string": True
        },
        {
            "name": "Using JSON Object With String Value",
            "json_data": {"data": '{"nested": "value"}'},
            "expected_success": False
        }
    ]
    
    # Run each test scenario
    for scenario in test_scenarios:
        print(f"\n== Testing: {scenario['name']} ==")
        
        data = scenario["json_data"]
        is_string = scenario.get("is_string", False)
        
        if not is_string:
            try:
                data = json.dumps(data)
            except Exception as e:
                print(f"❌ Error converting to JSON string: {str(e)}")
                continue
        
        print(f"JSON data: {data}")
        print(f"Type: {type(data)}")
        print(f"Expected success: {scenario['expected_success']}")
        
        # Try adding to graph
        try:
            result = client.add_graph_data(USER_ID, data, "json")
            
            if result and result.get("success"):
                success = True
                uuid = result.get("response", {}).get("uuid", "unknown")
                print(f"✅ Success! Added JSON data to graph. UUID: {uuid}")
            else:
                success = False
                error = result.get("error", "Unknown error") if result else "Empty result"
                print(f"❌ Failed: {error}")
            
            if success == scenario["expected_success"]:
                print(f"✓ Result matches expected outcome")
            else:
                print(f"✗ Result differs from expected outcome")
                
        except Exception as e:
            print(f"❌ Exception during test: {str(e)}")
            import traceback
            traceback.print_exc()
    
    # Test modifying the client implementation to handle potential issues
    print("\n== Testing modified client approach ==")
    
    test_data = '{"name": "Modified Client Test", "value": "This tests a more robust implementation"}'
    print(f"Test data: {test_data}")
    
    try:
        # Try to fix common JSON formatting issues that Claude might introduce
        if isinstance(test_data, str):
            # Handle potential extra quotes that Claude might add
            if test_data.startswith("'") and test_data.endswith("'"):
                test_data = test_data[1:-1]
            elif test_data.startswith('"') and test_data.endswith('"'):
                test_data = test_data[1:-1]
                
            # Check if it's already valid JSON
            try:
                # Just validate, but keep as string
                json.loads(test_data)
                valid_json = True
            except json.JSONDecodeError:
                valid_json = False
                print(f"Warning: Invalid JSON string format")
                
            if not valid_json:
                # Try to fix common issues
                try:
                    # If it looks like a Python dict literal, try to eval it safely
                    if test_data.strip().startswith("{") and test_data.strip().endswith("}"):
                        import ast
                        obj = ast.literal_eval(test_data)
                        test_data = json.dumps(obj)
                        print(f"Fixed with ast.literal_eval: {test_data}")
                except Exception as e:
                    print(f"Could not fix JSON format: {str(e)}")
        
        # Now try adding to graph
        result = client.add_graph_data(USER_ID, test_data, "json")
        
        if result and result.get("success"):
            print(f"✅ Successfully added with modified approach")
        else:
            error = result.get("error", "Unknown error") if result else "Empty result"
            print(f"❌ Failed with modified approach: {error}")
            
    except Exception as e:
        print(f"❌ Exception during modified test: {str(e)}")
    
    # Final summary
    print("\n=== Test Summary ===")
    print("Completed testing of Claude JSON handling scenarios")
    print("Based on these results, we can update the client implementation to handle Claude's JSON format better")

if __name__ == "__main__":
    test_claude_json_handling() 


================================================
FILE: scripts/test_dict_json.py
================================================
#!/usr/bin/env python3
"""
Script to test adding Python dictionaries directly as JSON data
This will help verify our fixes for Claude's JSON handling
"""

import os
import sys
import json
from dotenv import load_dotenv

# Add the parent directory to the path so we can import the client
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Load environment variables
load_dotenv()

# Import the necessary components
from core.zep_cloud_client import ZepCloudClient
from core.zep_cloud_server import add_graph_data

def test_direct_dictionary_handling():
    """Test adding a Python dictionary directly as JSON data"""
    print("\n=== Testing Python Dictionary as JSON Data ===")
    
    # Initialize the client
    try:
        client = ZepCloudClient()
        user_id = "test_dict_json_user"
        print("✅ Successfully initialized ZepCloudClient")
    except Exception as e:
        print(f"❌ Failed to initialize ZepCloudClient: {str(e)}")
        return False
    
    # Test data that simulates what Claude might send
    test_data = {
        "datetime": "2025-01-01T00:00:00Z", 
        "text": "Omg, today I had an orange pie and it was so good! I think I'm going to try baking orange pies from now on. Oh and I loved how crunchy it was."
    }
    
    print(f"\n📝 Test: Python Dictionary Object")
    print(f"Data type: {type(test_data)}")
    print(f"Data content: {test_data}")
    
    # Test with client directly
    try:
        result = client.add_graph_data(user_id, test_data, "json")
        
        success = result.get("success", False)
        print(f"\nClient Result: {'✅ Success' if success else '❌ Failure'}")
        if not success:
            print(f"Error: {result.get('error', 'Unknown error')}")
        else:
            print("✅ Successfully added dictionary data through client")
    except Exception as e:
        print(f"❌ Exception in client test: {str(e)}")
    
    # Test with server tool function
    print("\n== Testing Server Tool Function ==")
    try:
        # Convert the result to a string since that's what the tool returns
        result_json = add_graph_data(user_id, test_data, "json")
        result = json.loads(result_json)
        
        success = result.get("success", False)
        print(f"Server Result: {'✅ Success' if success else '❌ Failure'}")
        if not success:
            print(f"Error: {result.get('error', 'Unknown error')}")
        else:
            print("✅ Successfully added dictionary data through server tool")
    except Exception as e:
        print(f"❌ Exception in server test: {str(e)}")
    
    # Test exact scenario from user's error
    print("\n== Testing Exact User Scenario ==")
    escaped_json_string = '{\"datetime\": \"2025-01-01T00:00:00Z\", \"text\": \"Omg, today I had an orange pie and it was so good! I think I\'m going to try baking orange pies from now on. Oh and I loved how crunchy it was.\"}'
    
    print(f"Data (escaped JSON string): {escaped_json_string}")
    
    try:
        result_json = add_graph_data(user_id, escaped_json_string, "json")
        result = json.loads(result_json)
        
        success = result.get("success", False)
        print(f"Result with escaped string: {'✅ Success' if success else '❌ Failure'}")
        if not success:
            print(f"Error: {result.get('error', 'Unknown error')}")
        else:
            print("✅ Successfully handled escaped JSON string")
    except Exception as e:
        print(f"❌ Exception in escaped JSON test: {str(e)}")
    
    print("\n=== Test Complete ===")

if __name__ == "__main__":
    test_direct_dictionary_handling() 


================================================
FILE: scripts/test_graph_data.py
================================================
#!/usr/bin/env python3
"""
Script to test the Zep Cloud graph data addition functionality
This will add sample data to a user's graph and then search for it to verify it works
"""

import os
import sys
import json
import time
from pathlib import Path
from dotenv import load_dotenv

# Try loading environment variables
env_path = Path('.env')
if env_path.exists():
    load_dotenv(dotenv_path=env_path)
    print(f"Loaded environment from .env")
else:
    load_dotenv()  # Fallback to default .env
    print(f"Loaded environment from .env")

# User ID to test with - change this to a real user ID in your system
USER_ID = "16263830569"

# Import the Zep Cloud client
try:
    # Try to import from the core directory
    sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from core.zep_cloud_client import ZepCloudClient
    print("Successfully imported ZepCloudClient")
except ImportError as e:
    print(f"Failed to import ZepCloudClient: {str(e)}")
    print("Make sure zep_cloud_client.py is accessible.")
    sys.exit(1)

def test_add_graph_data():
    """Test adding different types of data to a user's graph and searching for it"""
    print(f"\n=== Testing graph data addition for user: {USER_ID} ===")
    
    # Create client
    try:
        client = ZepCloudClient()
        print(f"Successfully initialized ZepCloudClient")
    except Exception as e:
        print(f"Error initializing client: {str(e)}")
        sys.exit(1)
    
    # Test data for each type
    test_data = {
        "text": "This is a test document about artificial intelligence and its applications in healthcare. AI has the potential to transform patient diagnosis, treatment planning, and medical research.",
        
        "json": json.dumps({
            "name": "John Smith",
            "age": 35,
            "occupation": "Software Engineer",
            "skills": ["Python", "JavaScript", "Machine Learning"],
            "projects": [
                {"name": "Healthcare AI", "status": "In Progress"},
                {"name": "Data Analytics Platform", "status": "Completed"}
            ]
        }),
        
        "message": "User: I'm interested in learning more about how AI can help improve healthcare outcomes. Assistant: AI has several applications in healthcare, including improving diagnosis accuracy, personalizing treatment plans, and accelerating medical research."
    }
    
    # Add each type of data to the graph
    for data_type, data in test_data.items():
        print(f"\n== Testing data type: {data_type} ==")
        print(f"Adding {data_type} data to graph... ({len(data)} characters)")
        
        try:
            # Call the add_graph_data method
            result = client.add_graph_data(USER_ID, data, data_type)
            
            if result and result.get("success"):
                uuid = result.get("response", {}).get("uuid", "unknown")
                print(f"✅ Successfully added {data_type} data to graph. UUID: {uuid}")
            else:
                error = result.get("error", "Unknown error") if result else "Empty result"
                print(f"❌ Failed to add {data_type} data to graph: {error}")
                continue
                
            # Wait a moment for the data to be processed
            print("Waiting for data to be processed (2 seconds)...")
            time.sleep(2)
            
            # Now search for the data to verify it was added
            search_query = "healthcare AI" if data_type != "json" else "software engineer skills"
            print(f"Searching for '{search_query}' in graph...")
            
            search_result = client.search_graph(USER_ID, search_query, limit=5)
            
            if search_result:
                # Check if we got any results
                edges_count = len(search_result.get("edges", [])) if "edges" in search_result else 0
                nodes_count = len(search_result.get("nodes", [])) if "nodes" in search_result else 0
                results_count = len(search_result.get("results", [])) if "results" in search_result else 0
                
                print(f"Search results: edges={edges_count}, nodes={nodes_count}, combined={results_count}")
                
                if edges_count > 0 or nodes_count > 0 or results_count > 0:
                    print(f"✅ Data verification successful - found search results for {data_type} data")
                else:
                    print(f"⚠️ No search results found for {data_type} data. This might be normal if the data is still being processed.")
            else:
                print(f"❌ Search failed for {data_type} data")
        except Exception as e:
            print(f"Error during {data_type} data test: {str(e)}")
    
    # Final status
    print("\n=== Test Summary ===")
    print("Completed testing of graph data addition functionality")
    print("Note: If search verification didn't find results, it might be because Zep needs more time to process the data.")
    print("You can run this test again in a few minutes to check if the data becomes searchable.")

if __name__ == "__main__":
    test_add_graph_data() 


================================================
FILE: scripts/test_graph_search.py
================================================
#!/usr/bin/env python3
"""
Script to test the Zep Cloud graph search API directly
This will help verify if the user has any data in the graph
"""

import os
import sys
import json
from pathlib import Path
from dotenv import load_dotenv

# Try loading environment variables
env_path = Path('.env.new')
if env_path.exists():
    load_dotenv(dotenv_path=env_path)
    print(f"Loaded environment from .env.new")
else:
    load_dotenv()  # Fallback to default .env
    print(f"Loaded environment from .env")

# User ID to search for
USER_ID = "16263830569"

# Import the Zep Cloud client
try:
    # Try to import from the core directory
    sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from core.zep_cloud_client import ZepCloudClient
    print("Successfully imported ZepCloudClient")
except ImportError as e:
    print(f"Failed to import ZepCloudClient: {str(e)}")
    print("Make sure zep_cloud_client.py is accessible.")
    sys.exit(1)

def test_graph_search():
    """Test searching the graph for a specific user"""
    print(f"\n=== Testing graph search for user: {USER_ID} ===")
    
    # Create client
    try:
        client = ZepCloudClient()
        print(f"Successfully initialized ZepCloudClient")
    except Exception as e:
        print(f"Error initializing client: {str(e)}")
        sys.exit(1)
    
    # List of test queries to try
    test_queries = [
        "feelings emotions mood",
        "recent activities",
        "conversation history",
        "messages",
        "user information",
        "data",  # Very generic query to try to match anything
    ]
    
    # Try different search scopes
    scopes = ["edges", "nodes", "both"]
    
    # Try all combinations
    success = False
    for scope in scopes:
        print(f"\n== Testing scope: {scope} ==")
        for query in test_queries:
            print(f"\nTrying query: '{query}'")
            try:
                # Call the graph search method
                result = client.search_graph(USER_ID, query, limit=20, scope=scope)
                
                # Check if we got any results
                if result:
                    # Print node/edge counts
                    edges_count = len(result.get("edges", [])) if "edges" in result else 0
                    nodes_count = len(result.get("nodes", [])) if "nodes" in result else 0
                    results_count = len(result.get("results", [])) if "results" in result else 0
                    
                    print(f"Results: edges={edges_count}, nodes={nodes_count}, combined={results_count}")
                    
                    if edges_count > 0 or nodes_count > 0 or results_count > 0:
                        print("✅ FOUND DATA!")
                        print(json.dumps(result, indent=2))
                        success = True
                else:
                    print("No results returned (null response)")
            except Exception as e:
                print(f"Error searching graph: {str(e)}")
    
    # Final status
    if success:
        print("\n✅ SUCCESS: Found data for the user in at least one query.")
    else:
        print("\n❌ No data found for this user with any of the test queries.")
        print("This could mean one of these issues:")
        print("1. The user doesn't have any data in the Zep graph")
        print("2. The search scope or queries aren't matching the data")
        print("3. There are permission issues with the API key")
        print("4. The graph search endpoint isn't working as expected")

if __name__ == "__main__":
    test_graph_search() 


================================================
FILE: scripts/test_json_data.py
================================================
#!/usr/bin/env python3
"""
Script to specifically test adding JSON data to the Zep Cloud graph
This will help diagnose issues with JSON formatting and handling
"""

import os
import sys
import json
import time
from pathlib import Path
from dotenv import load_dotenv

# Try loading environment variables
env_path = Path('.env')
if env_path.exists():
    load_dotenv(dotenv_path=env_path)
    print(f"Loaded environment from .env")
else:
    load_dotenv()  # Fallback to default .env
    print(f"Loaded environment from .env")

# User ID to test with
USER_ID = "16263830569"

# Import the Zep Cloud client
try:
    # Try to import from the core directory
    sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from core.zep_cloud_client import ZepCloudClient
    print("Successfully imported ZepCloudClient")
except ImportError as e:
    print(f"Failed to import ZepCloudClient: {str(e)}")
    print("Make sure zep_cloud_client.py is accessible.")
    sys.exit(1)

def test_json_data_addition():
    """Test specifically adding JSON data to the graph with detailed diagnostics"""
    print(f"\n=== Testing JSON data addition for user: {USER_ID} ===")
    
    # Create client
    try:
        client = ZepCloudClient()
        print(f"Successfully initialized ZepCloudClient")
    except Exception as e:
        print(f"Error initializing client: {str(e)}")
        sys.exit(1)
    
    # Test different JSON payloads of increasing complexity
    json_test_data = [
        # Simple JSON object
        {
            "name": "Simple Test",
            "description": "A simple JSON object",
            "value": 42
        },
        
        # More complex JSON with nested objects
        {
            "user": {
                "name": "John Smith",
                "age": 35,
                "contact": {
                    "email": "john@example.com",
                    "phone": "555-1234"
                }
            },
            "preferences": {
                "theme": "dark",
                "notifications": True
            },
            "tags": ["test", "json", "data"]
        },
        
        # JSON with special characters
        {
            "title": "JSON with special chars: ✓, é, ñ",
            "content": "This includes quotes: \" and escaped chars \\ and new\nlines"
        }
    ]
    
    # Try each JSON payload
    for index, test_data in enumerate(json_test_data):
        print(f"\n== Test {index+1}: {test_data.get('name', 'JSON data')} ==")
        
        # Convert to JSON string
        try:
            # First try with standard JSON dumps
            json_string = json.dumps(test_data)
            print(f"JSON string (length: {len(json_string)}): {json_string[:100]}{'...' if len(json_string) > 100 else ''}")
        except Exception as e:
            print(f"❌ Error serializing JSON: {str(e)}")
            continue
        
        # Try adding to graph
        print("Adding JSON data to graph...")
        try:
            # Debug: Print the exact arguments being passed
            print(f"Debug - Arguments to add_graph_data:")
            print(f"  user_id: {USER_ID}")
            print(f"  data_type: json")
            print(f"  data: {json_string}")
            
            # Call the add_graph_data method with extensive error handling
            try:
                result = client.add_graph_data(USER_ID, json_string, "json")
                
                if result and result.get("success"):
                    uuid = result.get("response", {}).get("uuid", "unknown")
                    print(f"✅ Successfully added JSON data to graph. UUID: {uuid}")
                    print(f"Full response: {json.dumps(result, indent=2)}")
                else:
                    error = result.get("error", "Unknown error") if result else "Empty result"
                    print(f"❌ Failed to add JSON data to graph: {error}")
                    print(f"Full response: {json.dumps(result, indent=2) if result else 'None'}")
                    continue
            except Exception as e:
                print(f"❌ Exception during client.add_graph_data call: {str(e)}")
                import traceback
                traceback.print_exc()
                continue
                
            # Wait a moment for the data to be processed
            print("Waiting for data to be processed (2 seconds)...")
            time.sleep(2)
            
            # Now search for the data to verify it was added
            search_terms = [
                test_data.get("name", ""),
                test_data.get("description", ""),
                "json test"
            ]
            
            search_term = next((term for term in search_terms if term), "test")
            print(f"Searching for '{search_term}' in graph...")
            
            search_result = client.search_graph(USER_ID, search_term, limit=5)
            
            if search_result:
                # Check if we got any results
                edges_count = len(search_result.get("edges", [])) if "edges" in search_result else 0
                nodes_count = len(search_result.get("nodes", [])) if "nodes" in search_result else 0
                results_count = len(search_result.get("results", [])) if "results" in search_result else 0
                
                print(f"Search results: edges={edges_count}, nodes={nodes_count}, combined={results_count}")
                
                if edges_count > 0 or nodes_count > 0 or results_count > 0:
                    print(f"✅ Data verification successful - found search results for JSON data")
                else:
                    print(f"⚠️ No search results found for JSON data. This might be normal if the data is still being processed.")
            else:
                print(f"❌ Search failed")
        except Exception as e:
            print(f"Error during test: {str(e)}")
            import traceback
            traceback.print_exc()
    
    # Try direct JSON string approach
    print("\n== Testing direct JSON string approach ==")
    direct_json_string = '{"name":"Direct JSON String","value":42,"direct":true}'
    print(f"Adding direct JSON string to graph: {direct_json_string}")
    
    try:
        result = client.add_graph_data(USER_ID, direct_json_string, "json")
        if result and result.get("success"):
            print("✅ Successfully added direct JSON string")
        else:
            error = result.get("error", "Unknown error") if result else "Empty result"
            print(f"❌ Failed to add direct JSON string: {error}")
    except Exception as e:
        print(f"❌ Exception adding direct JSON string: {str(e)}")
    
    # Final status
    print("\n=== Test Summary ===")
    print("Completed testing of JSON data addition")
    print("If issues persist, check the ZepCloudClient implementation and the Zep API documentation.")

if __name__ == "__main__":
    test_json_data_addition() 


================================================
FILE: scripts/test_json_handling.py
================================================
#!/usr/bin/env python3

import os
import sys
import json
from dotenv import load_dotenv

# Add the parent directory to the path so we can import the client
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Load environment variables from .env file
load_dotenv()

# Import the ZepCloudClient
from core.zep_cloud_client import ZepCloudClient
from core.zep_cloud_server import add_graph_data

def test_client_json_handling():
    """Test the client's JSON handling directly"""
    print("\n=== Testing ZepCloudClient JSON Handling ===")
    
    # Initialize the client - no parameters needed as it uses environment variables
    try:
        client = ZepCloudClient()
        user_id = "test_user_json_handling"
    except Exception as e:
        print(f"❌ Failed to initialize ZepCloudClient: {str(e)}")
        print("Make sure ZEP_API_KEY environment variable is set")
        return False
    
    # Test cases
    test_cases = [
        {
            "name": "Valid JSON object",
            "data": '{"name": "John", "age": 30, "city": "New York"}',
            "expected_success": True
        },
        {
            "name": "Valid JSON with nested object",
            "data": '{"person": {"name": "John", "age": 30}, "address": {"city": "New York", "zip": "10001"}}',
            "expected_success": True
        },
        {
            "name": "Valid JSON array",
            "data": '[{"name": "John"}, {"name": "Jane"}]',
            "expected_success": True
        },
        {
            "name": "JSON with extra quotes",
            "data": '"{"name": "John", "age": 30}"',
            "expected_success": True
        },
        {
            "name": "Python dict (not string)",
            "data": {"name": "John", "age": 30, "city": "New York"},
            "expected_success": True
        },
        {
            "name": "JSON with syntax error",
            "data": '{"name": "John", "age": 30, city: "New York"}',  # Missing quotes around city
            "expected_success": False
        },
        {
            "name": "Completely invalid data",
            "data": 'This is not JSON at all',
            "expected_success": False
        }
    ]
    
    success_count = 0
    for test_case in test_cases:
        print(f"\n📝 Test: {test_case['name']}")
        print(f"Data: {test_case['data']}")
        
        try:
            result = client.add_graph_data(user_id, test_case['data'], "json")
            
            success = result.get("success", False)
            print(f"Result: {'✅ Success' if success else '❌ Failure'}")
            if not success:
                print(f"Error: {result.get('error', 'Unknown error')}")
            
            if success == test_case["expected_success"]:
                print(f"✅ Test passed (got expected result: {success})")
                success_count += 1
            else:
                print(f"❌ Test failed (expected {test_case['expected_success']}, got {success})")
        except Exception as e:
            print(f"❌ Exception: {str(e)}")
            if not test_case["expected_success"]:
                print(f"✅ Test actually passed (expected failure with exception)")
                success_count += 1
            else:
                print(f"❌ Test failed (unexpected exception)")
    
    print(f"\n=== Client Test Summary: {success_count}/{len(test_cases)} tests passed ===")
    return success_count == len(test_cases)

def test_server_json_handling():
    """Test the server's JSON handling via the tool function"""
    print("\n=== Testing Server Tool JSON Handling ===")
    
    user_id = "test_user_server_json"
    
    # Test cases
    test_cases = [
        {
            "name": "Valid JSON object",
            "data": '{"name": "John", "age": 30, "city": "New York"}',
            "expected_success": True
        },
        {
            "name": "JSON with extra quotes",
            "data": '"{"name": "John", "age": 30}"',
            "expected_success": True
        },
        {
            "name": "Single quotes instead of double",
            "data": "{'name': 'John', 'age': 30}",
            "expected_success": True
        },
        {
            "name": "JSON with Python-style trailing comma",
            "data": '{"name": "John", "age": 30,}',
            "expected_success": True
        },
        {
            "name": "JSON with syntax error",
            "data": '{"name": "John", "age": 30, city: "New York"}',  # Missing quotes around city
            "expected_success": False
        }
    ]
    
    success_count = 0
    for test_case in test_cases:
        print(f"\n📝 Test: {test_case['name']}")
        print(f"Data: {test_case['data']}")
        
        try:
            result_json = add_graph_data(user_id, test_case['data'], "json")
            result = json.loads(result_json)
            
            success = result.get("success", False)
            print(f"Result: {'✅ Success' if success else '❌ Failure'}")
            if not success:
                print(f"Error: {result.get('error', 'Unknown error')}")
            
            if success == test_case["expected_success"]:
                print(f"✅ Test passed (got expected result: {success})")
                success_count += 1
            else:
                print(f"❌ Test failed (expected {test_case['expected_success']}, got {success})")
        except Exception as e:
            print(f"❌ Exception: {str(e)}")
            if not test_case["expected_success"]:
                print(f"✅ Test actually passed (expected failure with exception)")
                success_count += 1
            else:
                print(f"❌ Test failed (unexpected exception)")
    
    print(f"\n=== Server Test Summary: {success_count}/{len(test_cases)} tests passed ===")
    return success_count == len(test_cases)

def main():
    print("🧪 Testing JSON handling for Zep Graph Data")
    
    client_success = test_client_json_handling()
    server_success = test_server_json_handling()
    
    print("\n=== Final Results ===")
    print(f"Client Tests: {'✅ PASSED' if client_success else '❌ FAILED'}")
    print(f"Server Tests: {'✅ PASSED' if server_success else '❌ FAILED'}")
    
    if client_success and server_success:
        print("\n🎉 All tests passed! Your JSON handling is robust.")
        return 0
    else:
        print("\n⚠️ Some tests failed. Review the output above for details.")
        return 1

if __name__ == "__main__":
    sys.exit(main()) 


================================================
FILE: scripts/test_mcp_add_graph_data.py
================================================
#!/usr/bin/env python3
"""
Script to test the MCP add_graph_data tool directly
This simulates Claude calling the tool through the MCP server
"""

import os
import sys
import json
import time
import subprocess
from pathlib import Path
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# User ID to test with
USER_ID = "16263830569"

# Path to the server script
SERVER_SCRIPT = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core", "zep_cloud_server.py")

def test_mcp_tool():
    """Test calling the add_graph_data MCP tool"""
    print(f"\n=== Testing MCP add_graph_data tool ===")
    print(f"Using server script at: {SERVER_SCRIPT}")
    
    # Test data
    test_data = "This is a test message added through the MCP server directly. It contains information about climate change and renewable energy."
    data_type = "text"
    
    # Start the server in a separate process
    print("\nStarting MCP server...")
    server_process = subprocess.Popen(
        ["python3", SERVER_SCRIPT],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )
    
    # Give the server time to start
    print("Waiting for server to start up (3 seconds)...")
    time.sleep(3)
    
    try:
        # Execute the mcp-eval command to call the tool
        print("\nCalling add_graph_data tool...")
        mcp_command = [
            "mcp-eval", 
            "--server", SERVER_SCRIPT,
            "--tool", "add_graph_data",
            "--args", json.dumps({
                "user_id": USER_ID,
                "data": test_data,
                "data_type": data_type
            })
        ]
        
        print(f"Running command: {' '.join(mcp_command)}")
        result = subprocess.run(
            mcp_command,
            capture_output=True,
            text=True
        )
        
        # Display the results
        print("\n=== Tool Call Results ===")
        if result.returncode == 0:
            print("✅ MCP tool call successful")
            print("Output:")
            try:
                result_json = json.loads(result.stdout)
                print(json.dumps(result_json, indent=2))
                
                if result_json.get("success"):
                    print("\n✅ Data successfully added to graph!")
                else:
                    print("\n❌ Failed to add data to graph:", result_json.get("error", "Unknown error"))
            except json.JSONDecodeError:
                print("Could not parse JSON response:")
                print(result.stdout)
        else:
            print("❌ MCP tool call failed")
            print(f"Return code: {result.returncode}")
            print("Error output:")
            print(result.stderr)
            
    except Exception as e:
        print(f"Error testing MCP tool: {str(e)}")
    finally:
        # Clean up the server process
        print("\nStopping MCP server...")
        server_process.terminate()
        try:
            server_process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            server_process.kill()
            
        stdout, stderr = server_process.communicate()
        if stdout:
            print("\nServer stdout:")
            print(stdout[:500] + "..." if len(stdout) > 500 else stdout)
        if stderr:
            print("\nServer stderr:")
            print(stderr[:500] + "..." if len(stderr) > 500 else stderr)
            
    print("\n=== Test Complete ===")

if __name__ == "__main__":
    test_mcp_tool() 


================================================
FILE: scripts/test_server_start.py
================================================
#!/usr/bin/env python3
"""
Script to test that the MCP server starts correctly
"""

import os
import sys
import time
import signal
import subprocess
from pathlib import Path

# Path to the server script
SERVER_SCRIPT = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core", "zep_cloud_server.py")

def test_server_startup():
    """Test that the server starts up correctly"""
    print(f"\n=== Testing MCP server startup ===")
    print(f"Using server script at: {SERVER_SCRIPT}")
    
    # Start the server in a separate process
    print("\nStarting MCP server...")
    server_process = subprocess.Popen(
        ["python3", SERVER_SCRIPT],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )
    
    # Give the server time to start
    print("Waiting for server to start up (5 seconds)...")
    time.sleep(5)
    
    # Check if server is running
    if server_process.poll() is None:
        print("✅ Server started successfully and is running")
    else:
        print("❌ Server failed to start or exited early")
        stdout, stderr = server_process.communicate()
        print("Server stdout:", stdout)
        print("Server stderr:", stderr)
        return
    
    try:
        # Keep server running for a bit to see logs
        print("\nServer is running. Press Ctrl+C to stop...")
        while server_process.poll() is None:
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("\nReceived Ctrl+C, stopping server...")
    finally:
        # Clean up the server process
        if server_process.poll() is None:
            print("Stopping MCP server...")
            server_process.send_signal(signal.SIGINT)
            try:
                server_process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                print("Server didn't stop gracefully, force killing...")
                server_process.kill()
                
        stdout, stderr = server_process.communicate()
        if stdout:
            print("\nServer stdout:")
            print(stdout)
        if stderr:
            print("\nServer stderr:")
            print(stderr)
            
    print("\n=== Test Complete ===")
    print("The MCP server started successfully. You can now connect to it using Claude Desktop.")
    print("Instructions for Claude Desktop:")
    print("1. Open Claude Desktop")
    print("2. Add this MCP server in Claude settings")
    print("3. In conversation with Claude, you can now use the add_graph_data tool")
    print(f"4. Server path: {os.path.abspath(SERVER_SCRIPT)}")

if __name__ == "__main__":
    test_server_startup() 


================================================
FILE: tests/test_comprehensive.py
================================================
#!/usr/bin/env python3
"""
Comprehensive test script for Zep Cloud API authentication.
This script examines the API key format and tries multiple authentication methods.
"""

import os
import re
import sys
import json
import base64
import requests
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Get Zep API Key from environment variables
ZEP_API_KEY = os.getenv("ZEP_API_KEY")
if not ZEP_API_KEY:
    print("Error: ZEP_API_KEY not found in environment variables.")
    print("Please set it in the .env file before running this test.")
    sys.exit(1)

# Zep Cloud API base URL
ZEP_CLOUD_API_URL = "https://api.getzep.com/api/v2"

def examine_token_format():
    """Examine the token format and structure"""
    print(f"\n===== TOKEN EXAMINATION =====")
    print(f"API Key length: {len(ZEP_API_KEY)}")
    print(f"API Key prefix: {ZEP_API_KEY[:5]}...")
    print(f"API Key suffix: ...{ZEP_API_KEY[-5:]}")
    
    # Check if it starts with "z_"
    if ZEP_API_KEY.startswith("z_"):
        print("Token starts with 'z_' prefix.")
        base_token = ZEP_API_KEY[2:]
    else:
        print("Token does not start with 'z_' prefix.")
        base_token = ZEP_API_KEY
    
    # Check if it looks like a JWT (three dot-separated base64 sections)
    jwt_pattern = r'^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+$'
    if re.match(jwt_pattern, base_token):
        print("Token appears to be in JWT format (header.payload.signature)")
        try:
            # Split the JWT into its components
            header, payload, signature = base_token.split('.')
            
            # Pad the base64 strings if necessary
            header_pad = header + '=' * (4 - len(header) % 4) if len(header) % 4 else header
            payload_pad = payload + '=' * (4 - len(payload) % 4) if len(payload) % 4 else payload
            
            # Decode header and payload
            header_json = base64.b64decode(header_pad.replace('-', '+').replace('_', '/')).decode('utf-8')
            payload_json = base64.b64decode(payload_pad.replace('-', '+').replace('_', '/')).decode('utf-8')
            
            print(f"JWT Header: {json.loads(header_json)}")
            print(f"JWT Payload: {json.loads(payload_json)}")
        except Exception as e:
            print(f"Error decoding JWT: {e}")
    else:
        print("Token does not appear to be in standard JWT format.")
    
    # Check if it could be basic auth (username:password in base64)
    try:
        decoded = base64.b64decode(base_token).decode('utf-8')
        if ':' in decoded:
            print("Token could be a base64-encoded Basic Auth credential (username:password).")
    except:
        pass

def test_auth_methods():
    """Test various authentication methods with the Zep Cloud API"""
    print(f"\n===== TESTING AUTHENTICATION METHODS =====")
    
    # Generate different authentication headers to try
    auth_methods = [
        {
            "name": "Standard Bearer token with full token",
            "headers": {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {ZEP_API_KEY}"
            }
        },
        {
            "name": "Bearer token without z_ prefix (if applicable)",
            "headers": {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {ZEP_API_KEY[2:]}" if ZEP_API_KEY.startswith("z_") else "N/A"
            }
        },
        {
            "name": "Bearer token with lowercase 'bearer'",
            "headers": {
                "Content-Type": "application/json",
                "Authorization": f"bearer {ZEP_API_KEY}"
            }
        },
        {
            "name": "API Key as header without Bearer prefix",
            "headers": {
                "Content-Type": "application/json",
                "Authorization": ZEP_API_KEY
            }
        },
        {
            "name": "Basic Auth with API key as username",
            "headers": {
                "Content-Type": "application/json",
                "Authorization": f"Basic {base64.b64encode(f'{ZEP_API_KEY}:'.encode()).decode()}"
            }
        },
        {
            "name": "Basic Auth with API key as password",
            "headers": {
                "Content-Type": "application/json",
                "Authorization": f"Basic {base64.b64encode(f':{ZEP_API_KEY}'.encode()).decode()}"
            }
        },
        {
            "name": "X-API-Key header",
            "headers": {
                "Content-Type": "application/json",
                "X-API-Key": ZEP_API_KEY
            }
        },
        {
            "name": "api_key query parameter",
            "headers": {
                "Content-Type": "application/json"
            },
            "params": {
                "api_key": ZEP_API_KEY
            }
        }
    ]
    
    # Remove N/A methods
    auth_methods = [method for method in auth_methods if method.get("headers", {}).get("Authorization", "") != "N/A"]
    
    # Endpoints to test against
    endpoints = [
        "/health",
        "/users",
        "",  # Root API endpoint
    ]
    
    success_found = False
    
    for endpoint in endpoints:
        url = f"{ZEP_CLOUD_API_URL}{endpoint}"
        print(f"\n----- Testing endpoint: {url} -----")
        
        for method in auth_methods:
            print(f"Trying {method['name']}...")
            try:
                params = method.get("params", {})
                response = requests.get(url, headers=method["headers"], params=params)
                
                print(f"Status code: {response.status_code}")
                print(f"Response: {response.text[:100]}..." if len(response.text) > 100 else f"Response: {response.text}")
                
                if response.status_code == 200:
                    print(f"✅ SUCCESS! {method['name']} worked!")
                    success_found = True
                    print("\nRecommended authentication method:")
                    print(f"Method: {method['name']}")
                    print(f"Headers: {json.dumps(method['headers'], indent=2)}")
                    if params:
                        print(f"Parameters: {json.dumps(params, indent=2)}")
                    return True
                else:
                    print(f"❌ Failed with {method['name']}")
            except Exception as e:
                print(f"❌ Error with {method['name']}: {str(e)}")
    
    if not success_found:
        print("\n❌ All authentication methods failed.")
        print("Suggestions:")
        print("1. Verify your API key is correct")
        print("2. Check if your Zep Cloud subscription is active")
        print("3. Contact Zep Cloud support for assistance")
    
    return False

if __name__ == "__main__":
    print(f"🔑 Testing Zep Cloud API Connection")
    print(f"API URL: {ZEP_CLOUD_API_URL}")
    print(f"API Key: {ZEP_API_KEY[:5]}...{ZEP_API_KEY[-5:]} (length: {len(ZEP_API_KEY)})")
    
    examine_token_format()
    success = test_auth_methods()
    
    if success:
        print("\n✅ Successfully authenticated with Zep Cloud API!")
        print("You can now use the MCP server with Claude Desktop.")
    else:
        print("\n❌ Unable to authenticate with Zep Cloud API.")
        print("Please check the issues mentioned above and try again.") 


================================================
FILE: tests/test_specific_user.py
================================================
#!/usr/bin/env python3
"""
Comprehensive test script for all operations on a specific user in Zep Cloud
"""

import os
import sys
import time
import json
import argparse
from pathlib import Path
from dotenv import load_dotenv

# Configure the specific user ID to test
USER_ID = "16263830569_aprilx"

# Try loading from both .env and .env.new
env_path = Path('.env.new')
if env_path.exists():
    load_dotenv(dotenv_path=env_path)
    print(f"Loaded environment from .env.new")
else:
    load_dotenv()  # Fallback to default .env
    print(f"Loaded environment from .env")

# Import the Zep Cloud client
try:
    from zep_cloud_client import ZepCloudClient
    print("Successfully imported ZepCloudClient")
except ImportError:
    print("Failed to import ZepCloudClient. Make sure zep_cloud_client.py is in the current directory.")
    sys.exit(1)

def check_user_exists(client, user_id, verbose=True):
    """Check if a user exists in Zep Cloud"""
    if verbose:
        print(f"\n=== Checking if user exists: {user_id} ===\n")
    
    try:
        user = client.get_user(user_id)
        
        if user:
            if verbose:
                print(f"✅ User exists: {user['user_id']}")
                print(f"Metadata: {json.dumps(user['metadata'], indent=2)}")
            return user
        else:
            if verbose:
                print(f"❌ User {user_id} does not exist")
            return None
    except Exception as e:
        if verbose:
            print(f"❌ Error checking user: {str(e)}")
        return None

def create_user(client, user_id, metadata=None):
    """Create a user in Zep Cloud"""
    print(f"\n=== Creating user: {user_id} ===\n")
    
    # Default metadata
    if metadata is None:
        metadata = {
            "created_at": time.time(),
            "description": "Test user created for production use",
            "source": "direct_api_call",
            "organization": "zep_cloud_test"
        }
    
    print(f"Attempting to create user with metadata:")
    print(json.dumps(metadata, indent=2))
    
    try:
        user = client.create_user(user_id, metadata)
        
        if user:
            print(f"\n✅ SUCCESS: Created user: {user['user_id']}")
            print(f"Metadata: {json.dumps(user['metadata'], indent=2)}")
            return user
        else:
            print(f"\n❌ ERROR: Failed to create user {user_id}")
            return None
    except Exception as e:
        print(f"\n❌ ERROR: Exception while creating user: {str(e)}")
        return None

def update_user(client, user_id, metadata):
    """Update a user in Zep Cloud"""
    print(f"\n=== Updating user: {user_id} ===\n")
    
    print(f"Attempting to update user with metadata:")
    print(json.dumps(metadata, indent=2))
    
    try:
        user = client.update_user(user_id, metadata)
        
        if user:
            print(f"\n✅ SUCCESS: Updated user: {user['user_id']}")
            print(f"Metadata: {json.dumps(user['metadata'], indent=2)}")
            return user
        else:
            print(f"\n❌ ERROR: Failed to update user {user_id}")
            return None
    except Exception as e:
        print(f"\n❌ ERROR: Exception while updating user: {str(e)}")
        return None

def delete_user(client, user_id):
    """Delete a user from Zep Cloud"""
    print(f"\n=== Deleting user: {user_id} ===\n")
    
    try:
        result = client.delete_user(user_id)
        
        if result:
            print(f"\n✅ SUCCESS: Deleted user: {user_id}")
            return True
        else:
            print(f"\n❌ ERROR: Failed to delete user {user_id}")
            return False
    except Exception as e:
        print(f"\n❌ ERROR: Exception while deleting user: {str(e)}")
        return False

def restore_user(client, user_id, metadata=None):
    """Restore a user if it was deleted"""
    # Default metadata
    if metadata is None:
        metadata = {
            "created_at": time.time(),
            "description": "Restored user",
            "source": "restore_operation",
            "organization": "zep_cloud_test"
        }
    
    return create_user(client, user_id, metadata)

def run_test_with_metadata(metadata=None):
    """Run a test with the specified metadata"""
    # Create client
    try:
        client = ZepCloudClient()
        print(f"Successfully initialized ZepCloudClient")
    except Exception as e:
        print(f"Error initializing client: {str(e)}")
        return False
    
    # Check if user exists
    original_user = check_user_exists(client, USER_ID)
    had_user_initially = original_user is not None
    
    if had_user_initially:
        print(f"\nUser {USER_ID} already exists. Will create, update, and preserve it.")
    else:
        print(f"\nUser {USER_ID} does not exist. Will create, update, and then delete it.")
    
    # Create the user if it doesn't exist
    if not had_user_initially:
        created_user = create_user(client, USER_ID, metadata)
        if not created_user:
            print("Failed to create user. Aborting test.")
            return False
    
    # Update the user with new metadata
    update_metadata = {
        "updated_at": time.time(),
        "description": "Updated test user",
        "test_operation": "update",
        "organization": "zep_cloud_test"
    }
    
    updated_user = update_user(client, USER_ID, update_metadata)
    if not updated_user:
        print("Failed to update user.")
        if not had_user_initially:
            print("Cleaning up by deleting the user we created.")
            delete_user(client, USER_ID)
        return False
    
    # Verify the user exists with updated metadata
    verified_user = check_user_exists(client, USER_ID)
    if not verified_user:
        print("Failed to verify user after update.")
        if not had_user_initially:
            print("Cleaning up by deleting the user we created.")
            delete_user(client, USER_ID)
        return False
    
    # Delete the user if we created it
    if not had_user_initially:
        deleted = delete_user(client, USER_ID)
        if not deleted:
            print("Failed to delete user.")
            return False
        
        # Verify the user is gone
        deleted_check = check_user_exists(client, USER_ID)
        if deleted_check:
            print("User still exists after deletion attempt.")
            return False
    else:
        # Restore the original user
        if original_user and "metadata" in original_user:
            restore_user(client, USER_ID, original_user["metadata"])
        else:
            # If we had a user but couldn't get its metadata, create with default metadata
            restore_user(client, USER_ID)
    
    print("\n✅ All operations completed successfully!")
    return True

def run_test_with_null_metadata():
    """Run a test with null metadata"""
    print("\n=== Testing with NULL metadata ===")
    return run_test_with_metadata(None)

def run_test_with_empty_metadata():
    """Run a test with empty dict metadata"""
    print("\n=== Testing with EMPTY DICT metadata ===")
    return run_test_with_metadata({})

def run_test_with_actual_metadata():
    """Run a test with actual metadata"""
    print("\n=== Testing with ACTUAL metadata ===")
    metadata = {
        "created_at": time.time(),
        "description": "Test user with actual metadata",
        "source": "direct_api_call",
        "test_case": "actual_metadata",
        "organization": "zep_cloud_test"
    }
    return run_test_with_metadata(metadata)

def main():
    print(f"\n=== Comprehensive Test for Zep Cloud User: {USER_ID} ===\n")
    
    parser = argparse.ArgumentParser(description='Test Zep Cloud user operations')
    parser.add_argument('--test-case', type=str, choices=['null', 'empty', 'actual', 'all'],
                       default='all', help='Test case to run (default: all)')
    
    args = parser.parse_args()
    
    if args.test_case == 'null' or args.test_case == 'all':
        test_null = run_test_with_null_metadata()
        if not test_null and args.test_case != 'all':
            return False
            
    if args.test_case == 'empty' or args.test_case == 'all':
        test_empty = run_test_with_empty_metadata()
        if not test_empty and args.test_case != 'all':
            return False
            
    if args.test_case == 'actual' or args.test_case == 'all':
        test_actual = run_test_with_actual_metadata()
        if not test_actual and args.test_case != 'all':
            return False
    
    print("\n=== Test Summary ===")
    if args.test_case == 'all':
        print("All test cases completed.")
    else:
        print(f"Test case '{args.test_case}' completed.")
    
    return True

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1) 


================================================
FILE: tests/test_zep_cloud_client.py
================================================
#!/usr/bin/env python3
"""
Test script for the ZepCloudClient
"""

import sys
import time
import uuid

from zep_cloud_client import ZepCloudClient

def test_list_users():
    """Test listing users"""
    print("\n=== Testing List Users ===")
    
    try:
        client = ZepCloudClient()
        users = client.list_users()
        
        print(f"Found {len(users)} users")
        # Print first 5 users
        for i, user in enumerate(users[:5]):
            print(f"User {i+1}: {user['user_id']}")
            
        return True
    
    except Exception as e:
        print(f"Error listing users: {str(e)}")
        return False

def test_get_user(user_id: str):
    """Test getting a user"""
    print(f"\n=== Testing Get User: {user_id} ===")
    
    try:
        client = ZepCloudClient()
        user = client.get_user(user_id)
        
        if user:
            print(f"Found user: {user['user_id']}")
            print(f"Metadata: {user['metadata']}")
            return True
        else:
            print(f"User {user_id} not found")
            return False
    
    except Exception as e:
        print(f"Error getting user: {str(e)}")
        return False

def test_create_user():
    """Test creating a user"""
    # Generate a unique user ID
    test_user_id = f"test_user_{int(time.time())}_{str(uuid.uuid4())[:8]}"
    print(f"\n=== Testing Create User: {test_user_id} ===")
    
    try:
        client = ZepCloudClient()
        
        # Create user with metadata
        metadata = {
            "test": True,
            "created_at": time.time(),
            "description": "Test user created by ZepCloudClient test script"
        }
        
        user = client.create_user(test_user_id, metadata)
        
        if user:
            print(f"Created user: {user['user_id']}")
            print(f"Metadata: {user['metadata']}")
            
            # Now test getting the user
            time.sleep(1)  # Brief pause to ensure user is created
            return test_get_user(test_user_id)
        else:
            print("Failed to create user")
            return False
    
    except Exception as e:
        print(f"Error creating user: {str(e)}")
        return False

def test_update_user(user_id: str):
    """Test updating a user"""
    print(f"\n=== Testing Update User: {user_id} ===")
    
    try:
        client = ZepCloudClient()
        
        # Get current user
        user = client.get_user(user_id)
        if not user:
            print(f"User {user_id} not found for update test")
            return False
            
        # Update metadata
        metadata = user["metadata"].copy() if user["metadata"] else {}
        metadata.update({
            "updated_at": time.time(),
            "update_test": True
        })
        
        updated_user = client.update_user(user_id, metadata)
        
        if updated_user:
            print(f"Updated user: {updated_user['user_id']}")
            print(f"Updated metadata: {updated_user['metadata']}")
            return True
        else:
            print(f"Failed to update user {user_id}")
            return False
    
    except Exception as e:
        print(f"Error updating user: {str(e)}")
        return False

def test_delete_user(user_id: str):
    """Test deleting a user"""
    print(f"\n=== Testing Delete User: {user_id} ===")
    
    try:
        client = ZepCloudClient()
        
        # Confirm user exists
        user = client.get_user(user_id)
        if not user:
            print(f"User {user_id} not found for delete test")
            return False
            
        # Delete user
        success = client.delete_user(user_id)
        
        if success:
            print(f"Successfully deleted user {user_id}")
            
            # Verify user is deleted
            time.sleep(1)  # Brief pause to ensure user is deleted
            deleted_user = client.get_user(user_id)
            
            if deleted_user:
                print(f"WARNING: User {user_id} still exists after deletion")
                return False
            else:
                print(f"Confirmed user {user_id} no longer exists")
                return True
        else:
            print(f"Failed to delete user {user_id}")
            return False
    
    except Exception as e:
        print(f"Error deleting user: {str(e)}")
        return False

def run_all_tests():
    """Run all tests"""
    print("\n=== Running All Zep Cloud Client Tests ===\n")
    
    # Test listing users
    list_success = test_list_users()
    
    # Test creating a user
    create_success = test_create_user()
    
    # The rest of the tests depend on create_success
    if create_success:
        # Get the newly created user ID
        client = ZepCloudClient()
        users = client.list_users()
        test_users = [u for u in users if u["user_id"].startswith("test_user_")]
        
        if test_users:
            test_user_id = test_users[0]["user_id"]
            print(f"\nUsing test user: {test_user_id}")
            
            # Test updating user
            update_success = test_update_user(test_user_id)
            
            # Test deleting user
            delete_success = test_delete_user(test_user_id)
            
            # Report results
            print("\n=== Test Results ===")
            print(f"List Users: {'✅ SUCCESS' if list_success else '❌ FAILED'}")
            print(f"Create User: {'✅ SUCCESS' if create_success else '❌ FAILED'}")
            print(f"Update User: {'✅ SUCCESS' if update_success else '❌ FAILED'}")
            print(f"Delete User: {'✅ SUCCESS' if delete_success else '❌ FAILED'}")
            
            return list_success and create_success and update_success and delete_success
        else:
            print("No test users found after creation")
            return False
    else:
        # Report partial results
        print("\n=== Test Results ===")
        print(f"List Users: {'✅ SUCCESS' if list_success else '❌ FAILED'}")
        print(f"Create User: {'✅ SUCCESS' if create_success else '❌ FAILED'}")
        print("Update User: ❌ SKIPPED (Create failed)")
        print("Delete User: ❌ SKIPPED (Create failed)")
        
        return False

if __name__ == "__main__":
    success = run_all_tests()
    
    if success:
        print("\n✅ All tests passed successfully!")
        sys.exit(0)
    else:
        print("\n❌ Some tests failed!")
        sys.exit(1) 

